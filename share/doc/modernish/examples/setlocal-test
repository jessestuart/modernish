#! /usr/bin/env modernish
#! use safe -w BUG_APPENDC
#! use var/setlocal
#! use var/stackextra

harden -p printf

# some old systems come without 'nl'
PATH=$DEFPATH command nl </dev/null 2>/dev/null
if not so; then
	nl() (
		num=0
		while read -r line; do
			printf '%6d\t%s\n' $((num+=1)) "$line"
		done
	)
else
	harden -p nl
fi

putln '-----Test 1-----'
putln 'Globbing off:'
put *
setlocal +o noglob; do
	putln '' 'Globbing on:'
	put *
	return 2
endlocal
putln '' "(Exit status of local block should be 2, was $?)"
putln 'Globbing off again:'
put *

putln '' '' '-----Test 2------'
X=12 Y=13
putln "     Global1:${CCt}X=$X${CCt}Y=$Y"
setlocal X=2 Y=4 splitthis='this string should not be subject to fieldsplitting.'; do
	putln "      Local1:${CCt}X=$X${CCt}Y=$Y"
	setlocal X=hi Y=there IFS splitthis='look ma, i can do local fieldsplitting!'; do
		putln "NestedLocal1:${CCt}X=$X${CCt}Y=$Y"
		X=13 Y=37
		putln "NestedLocal2:${CCt}X=$X${CCt}Y=$Y"
		putln $splitthis | nl
	endlocal
	putln "      Local2:${CCt}X=$X${CCt}Y=$Y"
	X=123 Y=456
	putln "      Local3:${CCt}X=$X${CCt}Y=$Y"
	putln $splitthis | nl
endlocal
putln "     Global2:${CCt}X=$X${CCt}Y=$Y"

putln '' '------Test 3------' '(If you see anything other than the files in your PWD below, there is an undiscovered bug!)'
# (Due to a bug, mksh [up to R54 2016/11/11] throws a syntax error if you use $( ) instead of ` `.
# Not that this really matters. In real-world programs you would not need to do this.)
result=`setlocal IFS= +o noglob; do printf '[%s] ' * | fold -s; endlocal`
putln $result

putln '' '------Test 3a------'
putln one two three four | setlocal X IFS=$CCn; do while read X; do put "[$X] "; done; echo; endlocal

putln '' '------Test 4------' 'Testing protection against stack corruption.'
setlocal testvar='stack corruption protection test: '; do
	put $testvar
	push var3
	push var3 var2
	push var3 var2 var1
	pop var3 var2 testvar var1   # this should fail due to a key mismatch
	let "$? == 2" || return 1
	stacksize --silent var3
	let "REPLY == 3" || return 1
	stacksize --silent var2
	let "REPLY == 2" || return 1
	stacksize --silent var1
	let "REPLY == 1" || return 1
	clearstack var1 var2 var3
endlocal && putln "ok" || putln "FAILED"

putln '' '------Test 5------' 'This test should fail with: "stack corrupted (failed to pop globals)".'
setlocal testvar=$CCv'stack corruption test test...'$CCn; do
	putln $testvar
	push testvar
	# Failing to restore a local variable's stack within the block will stop 'setlocal'
	# from restoring global settings due to a key mismatch, killing the program.
endlocal
putln 'Bad! We should never get here.'
