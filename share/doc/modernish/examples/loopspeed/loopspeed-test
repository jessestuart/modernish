#! /usr/bin/env modernish
#! use safe
#! use sys/cmd/harden
#! use var/loop
#! use sys/base/mktemp
#! use sys/base/which
#! use var/local

harden -p cat
harden -p cd
harden -p nl
harden -p tee

if match $ME */*; then
	cd ${ME%/*}
fi

if not command -V time >/dev/null; then
	exit 2 "No 'time' command available!"
fi

shell=$MSH_SHELL
modernish=$(command -v modernish) || exit 2 "Can't find modernish!"

# select a shell from a menu
selectshell() {
	which -as sh ash bash bosh dash yash zsh zsh5 ksh ksh93 pdksh mksh lksh oksh
	all_shells=$REPLY	# newline-separated list of shells
	# supplement 'which' results with any additional shells from /etc/shells
	if can read /etc/shells; then
		all_shells=${all_shells}${CCn}$(grep -E '/([bdy]?a|pdk|[mlo]?k|z)?sh[0-9._-]*$' /etc/shells)
	fi

	if empty $all_shells; then
		all_shells='(no shell found; enter path)'
	else
		all_shells=$(putln $all_shells | sort -u)
	fi
	LOCAL new_shell REPLY PS3='Shell number, command name or path: '; BEGIN
		LOOP select --split=$CCn new_shell in $all_shells; DO
			if empty $new_shell && not empty $REPLY; then
				# a path or command instead of a number was given
				checkshell $REPLY && break
			else
				# a number was chosen
				checkshell $new_shell && break
			fi
		DONE || {  
			putln 'Aborting.' # user pressed ^D:
			return		  # exit from LOCAL block (which is really a function)
		}
		shell=$new_shell
	END
}

# Checks for a valid shell; leaves full path in $new_shell if found ok.
checkshell() {
	LOCAL REPLY=$1; BEGIN
		if not contains $REPLY /; then
			which -s $REPLY  # store full path back in $REPLY
		fi
		if not is present $REPLY; then
			putln "$1 cannot be found."
			return 1
		fi
		if not can exec $REPLY; then
			putln "$REPLY is not an executable. Try another."
			return 1
		fi
		if not identic $($REPLY $MSH_PREFIX/bin/modernish -c 'putln okay') 'okay'; then
			putln "$REPLY cannot run modernish. Try another shell."
			return 1
		fi
		new_shell=$REPLY
	END >&2 || return
	putln "Shell $new_shell selected."
}

putln	'Type the number of the loop test you want to time, or type the' \
	"name of a shell to execute the tests in it (default: $MSH_SHELL)." \
	'Type "s" for a menu of shells. Type "exit" or Ctrl-D to exit.'

mktemp -sC  # silent+autocleanup; filename in REPLY
tmpscript=$REPLY

myPrefix_q=$MSH_PREFIX
shellquote myPrefix_q

# --- Main ---
LOOP select --fglob script in [0-9][0-9].*.msh; DO
	if not empty $script; then
		putln "Code of $script:"
		putln "#! $shell" "cd $myPrefix_q || exit" ". bin/modernish" >| $tmpscript
		cat $script | tee -a $tmpscript | nl -b a
		putln "Timing execution of $script with $shell..."
		time $shell $tmpscript || die "couldn't execute $tmpscript"
	else
		case $REPLY in
		( exit )	exit ;;
		( 's' )		selectshell ;;
		( * )		checkshell $REPLY && shell=$new_shell ;;
		esac
	fi
DONE || exit 0 "Exiting."  # user pressed ^D
