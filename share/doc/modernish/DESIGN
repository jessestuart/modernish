[ This document is unfinished and under development. ]

See also CODINGSTYLE.

Design notes for modernish itself:

* Robustness: All modernish library functions must work regardless of:

  - any currently set or unset POSIX shell options, except -e/errexit
  - the state of IFS field splitting
  - the current umask (even if it's 777)
  - the value of PATH (even if /dev/null)
  - spaces, newlines, or weird characters in arguments or file names
  - shell bugs detected & supported by modernish

  Defensive programming is the mantra.

* Security hardening:

  - If any inconsistent program state is detected, modernish must die(),
    invoking the reliable emergency halt that kills the entire program
    including all associated processes, instead of simply exit. This will often
    keep buggy scripts from wreaking havoc.

  - Always test for the correct arguments and die() if an incorrect number
    of arguments is given. This catches any unexpected field splitting and
    globbing (unquoted variables expanding into multiple arguments) which
    strongly indicates that the program is in an insonsistent state.

  - Always validate or sanitise all data before use. Die() on invalid data.
    This prevents injection vulnerabilities and buggy behaviour.

* Optimise for speed, even if this causes repetitive code.
  Avoid launching subshells like the plague unless there is no alternative
  (command substitution, piping into loops, ( ), all launch subshells).

* Optimise for the legibility of the code that uses modernish.
  Examples:
  - The 'so' and 'not' aliases allow 'if so; then' and 'if not so; then'
  - arithmetic and string tests are sensibly named shell functions
  - ...
