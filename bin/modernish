#! /bin/sh
# -*- mode: sh; -*-

# modernish - a cross-platform POSIX shell modernizer library.
#
# Goals:
# 1. realise the POSIX promise of "write once, adopt everywhere" for the shell
# 2. fix frequent shell language pitfalls and annoyances
# 3. extend the shell language with useful features
#
# POSIX reference: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/contents.html
#
# --- begin license ---
# Copyright (c) 2018 Martijn Dekker <martijn@inlv.org>, Groningen, Netherlands
# 
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
# 
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
# --- end license ---

# -------------

case ${MSH_VERSION+s} in
( s )	if ! { (unset -v MSH_VERSION) 2>|/dev/null && unset -v MSH_VERSION; }; then
		case $MSH_VERSION in
		( failedinit )	echo 'Initialisation has previously failed. Try another shell.' 1>&2 ;;
		( * )		echo 'Already initialised. To reload modernish, exit this shell first.' 1>&2 ;;
		esac
		case $- in
		( *i* )	return 124 ;;
		esac
		\exit 124
	fi ;;
esac

# -------------

# Initialization, phase 1.

# Modernish does _not_ support -e (-o errexit).
# Rationale: http://mywiki.wooledge.org/BashFAQ/105
# (and the inconsistencies mentioned there are just between bash versions...)
# Modernish provides a better alternative: the 'harden' function catches
# errors reliably on a command-by-command basis.
set +e

# Save and turn off 'allexport' to avoid exporting internal variables.
case $- in
( *a* )	set +a; _Msh_allexport=y ;;
( * )	unset -v _Msh_allexport ;;
esac

# Set default system $PATH, a path guaranteed to find standard POSIX utilities.
# Note: 'command -p' is supposed to search for a command with this default path.
# However, many existing shell binaries have the wrong path compiled in (e.g.
# Solaris bash or dtksh). Hence, modernish cannot rely on 'command -p'. So,
# instead of
#	command -p id -u
# do
#	PATH=$DEFPATH command id -u
# which always works. The side effect is exporting PATH but in most cases that doesn't matter.
# The value below is system-dependent; install.sh will hardcode it here.
DEFPATH=$(PATH=/usr/xpg6/bin:/usr/xpg4/bin:/bin:/usr/bin:$PATH command getconf PATH 2>/dev/null) || DEFPATH=/bin:/usr/bin:/sbin:/usr/sbin
readonly DEFPATH

# The version and location of modernish.
MSH_VERSION=0.9.1dev
MSH_SHELL=${MSH_SHELL:-$(PATH=$DEFPATH sh -c 'command -v sh || which sh || echo /bin/sh')}
MSH_PREFIX=${srcdir:-$PWD}		# this line and the previous will be changed by install.sh

# Internal function for aborting initialisation.
# Usage: _Msh_initExit "error message"
_Msh_initExit() {
	PATH=$DEFPATH
	if [ -e ~/.config/modernish/ignorefatalbugs ]; then
		printf 'modernish: %s\n' "$@" "Continuing anyway. THINGS WILL BREAK." 1>&2
		PATH=/dev/null
		return 0
	fi
	printf 'modernish: %s\n' "$@" "Initialisation failed. Aborting." 1>&2
	MSH_VERSION=failedinit
	readonly MSH_VERSION
	case $- in
	( *i* )	# try not to exit an interactive shell
		PATH=${_Msh_PATH}
		case ${_Msh_IFS+s} in
		( s )	IFS=${_Msh_IFS} ;;
		( * )	unset -v IFS ;;
		esac
		kill -INT "$$" || kill -s INT "$$" ;;
	esac 2>|/dev/null
	\exit 124
}

# Do the entire initialisation with PATH=/dev/null, so we can test for builtins without external commands interfering.
# Don't use regular builtins (e.g. 'test'/'[') without PATH=$DEFPATH, or yash in POSIX mode won't find them.
_Msh_PATH=$PATH
PATH=/dev/null

# Save IFS (including its value and whether it is set or unset) to restore it at the end of initialisation.
# Due to BUG_IFSISSET on ksh93, we can't test if IFS is set by any normal method, and we also can't know yet if we're on ksh93
# or not. So use the workaround here, which is to analyse field splitting behaviour (this thankfully works on all shells).
_Msh_testFn() {
	case ${IFS:+n} in	# non-empty: it is set
	( '' )	set -- "a b c"	# empty: test for default field splitting
		set -- $1
		case $# in
		( 1 )	;;	# no field splitting: it is empty and set
		( * )	! : ;;	# default field splitting: it is unset
		esac ;;
	esac
}
_Msh_testFn && _Msh_IFS=$IFS || unset -v _Msh_IFS

# Remove all aliases from the execution environment, as some shells set
# unhelpful default aliases. (Particularly, AT&T ksh sets
#	alias command="command "
# which defeats the ability of 'command' to bypass aliases, which would break
# feature testing using the "thisshellhas" function).
# On interactive shells, only remove certain aliases that would definitely
# interfere, to avoid undoing system or user profile settings.
unset -v _Msh_FTL_UNALIASA
case $- in
( *i* )	\unalias command alias unalias set unset exit return eval \
		echo kill printf test showusage \
		@ROFUNC@	# install.sh will replace this tag
	;;
( * )	\unalias -a \
	|| case ${ZSH_VERSION+s} in
	# TODO: remove when we stop supporting zsh 5.0.7
	( s )	\unalias -m '*' ;;
	esac || _Msh_FTL_UNALIASA=y ;;
esac 2>| /dev/null

# _Msh_cap (capabilities; also quirks and bugs) is space-separated. Each ID in
# ${_Msh_cap} should only contain ASCII capital letters A-Z, digits 0-9, and (for
# bugs or quirks) the underscore. Maximum length per ID is 13 characters.
unset -v _Msh_cap	# unexport, just in case
_Msh_cap=''

# Helper variable and function.
_Msh_ftlcount=0
_Msh_have() {
	_Msh_cap=${_Msh_cap:+${_Msh_cap} }$1
	case $1 in
	( FTL_* )
		PATH=$DEFPATH printf \
			'[%s]\t%s\n' "$1" "$2" 1>&2		# Formats well if $1 is max 13 chars
		_Msh_ftlcount=$(( ${_Msh_ftlcount} + 1 ))	# FTL_NOARITH compatible addition
		;;
	esac
}

# Request standards compliance.

# ... first, a sanity check
case ${YASH_VERSION+s}${KSH_VERSION+s}${SH_VERSION+s}${ZSH_VERSION+s}${BASH_VERSION+s}${POSH_VERSION+s} in
( s )	;;
( '' )	command set -o posix 2>/dev/null ;;	# Try if a non-identifiable shell has a POSIX option
( * )	_Msh_initExit "sanity check failed: more than one shell version identifier variable found" ;;
esac

# ... on non-interactive shells, turn off brace expansion by default, if it exists
case $- in
( *i* )	;;
( * )	_Msh_testFn() {
		command set +o braceexpand 2>/dev/null
		# FTL_CMDPP: bosh (schilytools sh) 2018-03-01
		case $#,${1-},${2-},${3-} in
		( 3,a,b,c ) ;;
		( * )	_Msh_have FTL_CMDPP "Error in 'command set ...' overwrites positional parameters." ;;
		esac
	}
	_Msh_testFn a b c ;;
esac

# ... zsh:
#	Note: zsh has more reserved words than other shells, so these are
#	not usable for function names, including:
#		declare end float foreach integer local nocorrect repeat
#	If you need one or more of these names, use something like:
#		isset ZSH_VERSION && disable -r repeat
case ${ZSH_VERSION+z} in
( z )	emulate -R sh
	# We need POSIX_ARGZERO for correct initialisation in phase 2.
	setopt POSIX_ARGZERO
	# Enable UTF-8 support if we're in such a locale.
	setopt MULTIBYTE 2>/dev/null
	# FTL_FLOWCORR: Program flow corruption if a subshell exits due to an error.
	# Due to the nature of the bug, this must be tested using a helper dot
	# script. See that file for details. (zsh on Solaris 11.3)
	. "$MSH_PREFIX/libexec/modernish/cap/aux/FTL_FLOWCORR.t" \
	&& _Msh_have FTL_FLOWCORR "Program flow corruption if a subshell exits due to an error."
	# On zsh < 5.3, "readonly" works like "typeset -r" even in POSIX mode,
	# meaning readonly variables set in functions are local to functions,
	# which is contrary to our usage and POSIX. Test for that bug and make
	# "readonly" do "typeset -rg" if found, making them global.
	# TODO: remove when we stop supporting zsh < 5.3
	unset -v _Msh_RO
	_Msh_testFn() {
		readonly _Msh_RO=y
	}
	_Msh_testFn
	case ${_Msh_RO-} in
	( y )	unsetopt POSIX_BUILTINS	# allow 'typeset +r'
		typeset +r _Msh_RO
		setopt POSIX_BUILTINS
		unset -v _Msh_RO ;;
	( * )	disable -r readonly 2>/dev/null	# it's a reserved word on zsh 5.2
		disable readonly
		eval 'function readonly { typeset -rg "$@"; }'
		alias readonly='typeset -rg' ;;
		# In stage 2 init at the end, we'll redefine this alias to be
		# properly conditional upon posixbuiltins. Not doing this now
		# as it comes at the cost of forking a subshell and
		# modernish init doesn't need it.
	esac
	if ! unset -f _Msh_nonexistent_fn 2>/dev/null; then
		# 'unset -f' complains about nonexistent functions (contra POSIX);
		# make it quietly accept them like other shells.
		# TODO: remove when we stop supporing zsh < 5.5
		eval 'function unset {
			case $1 in
			( -f )  builtin unset "$@" 2>/dev/null || : ;;
			( * )	builtin unset "$@" ;;
			esac
		}'
	fi
	# Make zsh even more POSIXy for cross-shell scripts only.
	case $0 in
	( modernish | */modernish )
		# These zsh-specific reserved words may interfere with shell functions.
		disable -r end foreach nocorrect repeat 2>/dev/null
		# These revert to builtins, subject to KSH_TYPESET, which is off by default for sh.
		disable -r declare export float integer local readonly typeset 2>/dev/null
		# Counting line numbers of 'eval' commands is more in line with other shells.
		setopt EVAL_LINENO
		;;
	esac
	;;
esac

# ... pdksh and derivatives (oksh, mksh, lksh, ... ?)
case ${KSH_VERSION:-${SH_VERSION:-}} in
( '@(#)'* )
	set -o posix
	# mksh/lksh have UTF-8 support as of R38, but it needs to be turned on
	# explicitly with 'set -U'; the locale is not detected for scripts,
	# presumably for backwards compatibility with OpenBSD which only
	# supports ASCII. The recipe below is recommended by mksh's man page.
	case ${KSH_VERSION:-} in
	( '@(#)MIRBSD KSH '* | '@(#)LEGACY KSH '* )
		case ${LC_ALL:-${LC_CTYPE:-${LANG:-}}} in
		( *[Uu][Tt][Ff]8* | *[Uu][Tt][Ff]-8* )
			set -U ;;
		( * )	set +U ;;
		esac ;;
	esac ;;
esac

# ... yash: it's very POSIX compliant even without posix mode, but unlike in
# other shells, posix mode disables non-standard functionality that scripts
# might want to test for and use (e.g. local variables, floating point arith).
# Yash in posix mode is also the only shell that honours the POSIX requirement
# that regular built-in utililities must have an existing external equivalent
# in order to be executed. This means that, in posix mode, yash will search
# $PATH before each execution of any regular built-in, which severely impacts
# performance.
# For these two reasons, perhaps it's better to leave posix mode off for yash.
# However, for compatibility testing purposes, it's very useful to turn it on,
# because it's the strictest POSIX compliance check available.
#case ${YASH_VERSION+s} in ( s ) set -o posix ;; esac

# ... external commands:
export POSIXLY_CORRECT=y	# this also sets -o posix on bash

# --- end of standards compliance requests ---

# -------------

# --- Built-in shell feature, quirk, bug and POSIX compliance requirement checks ---
# Block on fatal shell bugs and standards incompatibilities that would break
# modernish. Identify quirks and nonstandard features. As a side effect,
# also do some of the initialization.
#
# NOTE: all tests need to be compatible with all the bugs tested for (even
# the fatal ones), so that modernish can give a full report.

# FTL_NOALIAS: No aliases (Debian posh; bash "minimal configuration").
alias test=test 2>|/dev/null || _Msh_have FTL_NOALIAS 'No support for aliases at all.'
unalias test 2>|/dev/null	# AT&T ksh93 can't unalias in a subshell. Since install.sh does a test
				# initialisation modernish in a subshell, we can't fail on 'unalias'.

# FTL_UNALIASA: Can't remove all aliases. (Tested earlier)
case ${_Msh_FTL_UNALIASA+s} in
( s )  _Msh_have FTL_UNALIASA "No support for 'unalias -a'." ;;
esac

# Make sure that we have a way to guarantee running a shell builtin.
# Note: we can only use 'special builtins' here or yash in posix mode will fail this test.
# See: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_14
# FTL_NOCOMMAND: Debian posh; zsh < 4.2
{	unset -f command
	_Msh_test=x
	command -v unset \
	&& command -V unset \
	&& command -p unset _Msh_test \
	&& case ${_Msh_test+s} in ( s ) false ;; esac
} >| /dev/null 2>&1 || _Msh_have FTL_NOCOMMAND "No or broken 'command' builtin."

# FTL_COMMAND2P: double parsing of grammar and/or parameter expansion
# when using 'command' with an external command.
# (AT&T ksh88; schilytools sh <= 2017-08-14)
unset -v _Msh_test
command /dev/null \${_Msh_test=x} 2>/dev/null
case ${_Msh_test+s} in
( s )	_Msh_have FTL_COMMAND2P "'command' builtin with external cmd doubly parses expansions." ;;
esac

# On some shells (e.g. mksh), the POSIX 'type' command is an alias. We just
# killed it, so restore it, to avoid it being either missing or run as an
# external command (where the results w.r.t. what is a builtin don't apply
# to the currrent shell).
# In all the shells I've tested except bash (which has 'type -t'), the
# 'type' output is exactly equivalent to 'command -V' (capital V). However,
# POSIX standardises 'command -V' in more detail than it does 'type', while
# every possible output of 'command -V' also matches the less-detailed
# definition of 'type'.
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/command.html
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/type.html
case " ${_Msh_cap} " in
( *\ FTL_NOALIAS\ * ) ;;	# skip: not applicable
( * )	command -V type >| /dev/null 2>&1 || alias type='command -V' ;;
esac

# FTL_DEVCLOBBR: Can't write to devices if 'set -o noclobber' is active.
# Workaround: use >| instead of >
# (NetBSD /bin/sh)
_Msh_test=
case $- in
( *C* )	command : >/dev/null ;;
( * )	_Msh_test=C; set -C; command : >/dev/null ;;
esac 2>|/dev/null || _Msh_have FTL_DEVCLOBBR "Can't redirect to devices if 'set -o noclobber'."
case ${_Msh_test-} in
( C )	set +C ;;
esac

# FTL_NOARITH, BUG_NOOCTAL
# Test for complete POSIX shell arithmetics support. Run test in a subshell
# because shells exit on 'syntax error', thwarting our error message.
# Test for arithmetic:
#	- additive assignment (+=)
#	- comparison (==, >)
#	- conditional expression (x?y:z)
#	- hexadecimal numbers (0x2A == 42)
#	- octal numbers (014 == 12, 015 == 13)
# (NetBSD /bin/sh, Slackware /bin/ash, original pdksh (no hex or octal)).
(	i=7
	j=0
	case $(( ((j+=6*i)==0x2A)>0 ? 014 : 015 )) in
	( 12 )	case $j in
		( 42 )	;;
		( * )	\exit 1 ;;
		esac ;;
	( 14 )	case $j in
		( 42 )	\exit 14 ;;
		( * )	\exit 1 ;;
		esac ;;
	( * )	\exit 1 ;;
	esac
) 2>| /dev/null \
|| case $? in
( 14 )	_Msh_have BUG_NOOCTAL ;;
( * )	_Msh_have FTL_NOARITH "Incomplete and/or broken POSIX shell arithmetics." ;;
esac

# ... fatal bugs with 'case' ...

# pdksh 5.2.14nb5 from NetBSD pkgsrc has a very obscure bug: it fails to
# match a list of characters from a variable in a bracket pattern, but only
# if the variable name is exactly 14 characters long! (It breaks
# shellquote() because $SHELLSAFECHARS, which it uses in a bracket
# pattern, is a 14 character variable name.)
_Msh_test_1234=x	# 14 character variable name
case x in
( [${_Msh_test_1234}] ) ;;
( * )	_Msh_have FTL_FOURTEEN "Problem with 14 characters long variable names." ;;
esac
unset -v _Msh_test_1234

# FTL_CASEQUOT: can't use quotes in 'case' matching patterns. (Debian posh)
case " some stuff here " in
( *' stuff '* ) ;;
( * )	_Msh_have FTL_CASEQUOT "Can't use quotes in 'case' matching patterns." ;;
esac

# FTL_BRACSQBR: the closing square bracket ']', even if escaped or passed
# from a quoted variable, causes a non-match in a glob bracket pattern, even
# if another character is matched. In other words, bracket patterns can never
# contain the closing square bracket as a character to match.
# Bug found on:
# - older FreeBSD /bin/sh
# - AT&T ksh93 "JM 93t+ 2010-03-05" and "JM 93t+ 2010-06-21"
_Msh_test=']abcd'
case c in
( *["${_Msh_test}"]* )
	case e in
	( *[!"${_Msh_test}"]* ) ;;
	( * ) _Msh_have FTL_BRACSQBR "Negated bracket patterns can't contain a quoted closing square bracket." ;;
	esac ;;
( * )	_Msh_have FTL_BRACSQBR "Bracket patterns can't contain a quoted closing square bracket." ;;
esac

# FTL_BRACHYPH: a hyphen anywhere in a bracket pattern always produces a
# positive match. (AT&T ksh Version M 1993-12-28 p, at least on Mac OS X 10.4)
case e in
( [a-] | [a-d] | [-a] ) _Msh_have FTL_BRACHYPH "Hyphen produces false positive in bracket patterns." ;;
esac

# FTL_ORNOT: '!' does not invert the exit status of a 'case' after '||'
# (discovered in busybox ash 1.25.0git; no one runs old dev code, but it is
# trivial to test for this in case another shell ever has a bug with '!')
{ ! : || ! case x in x) ;; esac; } && _Msh_have FTL_ORNOT "'!' does not reliably invert exit status."

# FTL_GLOBHIBYT: glob patterns don't match high-byte characters (> 127).
# Found in bosh when compiled on Linux. Probably a bug in glibc.
case ö in
( * )	;;
( ö )	_Msh_have FTL_GLOBHIBYT "Glob patterns don't match high-byte characters." ;;
esac

# FTL_CASEBKSL: Double-quoted patterns don't match unescaped backslashes. (found in Busybox ash 1.28.0)
case \\z in
( "\z" ) ;;
( * )	_Msh_have FTL_CASEBKSL "Double-quoted patterns with unescaped backslashes don't match." ;;
esac

# ... end of fatal bugs with 'case' ...

# FTL_PARONEARG: When IFS is empty on most versions of pdksh (i.e. field
# splitting is off), "$@" is counted as a single argument instead of each
# positional parameter as separate arguments. This is unlike every other
# shell and contrary to the standard as the working of "$@" is unrelated to
# field splitting. Sadly this means neither of NetBSD's or OpenBSD's default
# shells can run modernish.
#
# BUG_PARONEARG: Like FTL_PARONEARG, but for ${1+"$@"}. (bash 3.x, 4.x)
IFS=''
_Msh_testFn() {
	_Msh_testFn2 "$@" || { _Msh_have FTL_PARONEARG \
	'"$@" becomes one single argument if field splitting is disabled.'	# pdksh, oksh, posh, mksh before R44
	return; }
	_Msh_testFn2 ${1+"$@"} || _Msh_have BUG_PARONEARG			# bash 3.x and 4.x; old zsh 4.x
}
_Msh_testFn2() {
	case $# in
	( 1 )	return 1 ;;
	( 4 )	;;
	( * )	_Msh_have FTL_PARNEWBUG 'Undiscovered bug with "$@"! Please report.' "($#)" ;;
	esac
}
_Msh_testFn "   \on\e" "\tw'o" " \th\'re\e" " \\'fo\u\r "

# FTL_SUBSTIFS: parameter substitution changes all existing spaces in the
# variable to the first character in IFS. (zsh 4.1.1)
_Msh_test='1 2 3'
IFS='x '  # this zsh bug is only triggered if IFS has space as 2nd char
_Msh_test=${_Msh_test+$_Msh_test }4\ 5
IFS=' '
case ${_Msh_test} in
( '1 2 3 4 5' )	;;
( '1x2x3 4 5' )	_Msh_have FTL_SUBSTIFS "Parameter substitution changes spaces to IFS char." ;;
( '*' )		_Msh_have FTL_PSTNEWBUG "Undiscovered bug with parameter substitution! (${_Msh_test})" ;;
esac

# FTL_PSUB: parameter substitution fails to match certain
# patterns. (yash < 2.40)
#  *  The parameter expansion ${foo##bar*} was being treated like
#     ${foo##bar} where the asterisk should match up to the end of the
#     parameter value.
#  *  The parameter expansion ${foo%%*} was being expanded to ${foo}
#     where it should expand to an empty string.
_Msh_test='barbarfoo'
case ${_Msh_test##bar*}/${_Msh_test%%*} in
( / )	;;
( barfoo/barbarfoo )
	_Msh_have FTL_PSUB "Parameter substitution fails to match certain patterns.${YASH_VERSION+ (yash 2.40 fixes this)}" ;;
( * )	_Msh_have FTL_PSUBNEW "Undiscovered bug with parameter substitution! (${_Msh_test##bar*}/${_Msh_test%%*})" ;;
esac

# FTL_PSUB2: glob patterns in parameter substitutions (#, %, ##, %%) are wrongly
# subject to parsing under certain conditions: expansions, command substitution,
# backslash parsing. (bosh/schily sh <= 2017-11-21)
_Msh_test='a${_Msh_test2=BUG}'
unset -v _Msh_test2
_Msh_test=${_Msh_test%"${_Msh_test#a}"}   # "
case ${_Msh_test},${_Msh_test2-}, in	# FTL_PSUB4 compat: extra comma
( 'a,,' ) ;;
( 'a${_Msh_test2=BUG},BUG,' )
	_Msh_have FTL_PSUB2 "Parameter substitution: patterns wrongly subject to expansions." ;;
( * )	_Msh_have FTL_PSUB2NEW "Undiscovered bug with parameter substitution! (${_Msh_test},${_Msh_test2-})" ;;
esac

# FTL_PSUB3: glob patterns in parameter substitutions (#, %, ##, %%) cause
# quoted patterns to not match. (bosh/schily sh 2018-03-01)
_Msh_test=abcdefghij
_Msh_test2=efg
case ${_Msh_test#*"$_Msh_test2"} in
( hij ) ;;
( abcdefghij )
	_Msh_have FTL_PSUB3 "Parameter substitution: quoted patterns fail to match." ;;
( * )	_Msh_have FTL_PSUB3NEW "Undiscovered bug with parameter substitution! (${_Msh_test#*"$_Msh_test2"})" ;;
esac

# FTL_PSUB4: a parameter substitution of the form ${var-} or ${var:-},
# at the end of an argument, erases the entire argument. (mksh R50d)
_Msh_test=
case foo${_Msh_test:-} in
( '' )	_Msh_have FTL_PSUB4 "Parameters of form \${var-} or \${var:-} erase entire preceding word." ;;
esac

# FTL_PSUBPP: if a parameter substitution modifies one positional parameter with a
# pattern containing another positional parameter, the result is corrupted. (pdksh)
_Msh_testFn() {
	set ' foo -> bar' foo
	case ${1#" $2 -> "} in
	( bar ) ;;
	( * ) return 1 ;;
	esac
}
if ! _Msh_testFn; then
	_Msh_have FTL_PSUBPP "Parameter substitutions on positional parameters are corrupted."
fi

# FTL_EVALRET: shell doesn't return from a function if the "return"
# is within an 'eval', but only from the 'eval'. (yash < 2.39)
# http://osdn.jp/ticket/browse.php?group_id=3863&tid=35232
# (In modernish 0.02dev this was a non-fatal BUG_EVALRET and the code
# included workarounds, but yash up to 2.39 turns out to have FTL_PSUB,
# so we can stop working around bugs from that version and before.)
_Msh_testFn() { true; eval "return $?"; false; }
if ! _Msh_testFn; then
	_Msh_have FTL_EVALRET "No return from function if 'return' within 'eval'.${YASH_VERSION+ (yash 2.39 fixes this)}"
fi

# FTL_EVALERR: 'eval' does not return an error exit status (> 0) on syntax
# error. This kills all feature testing based on shell grammar features,
# giving false positives on tests like HERESTR.t, causing subsequent breakage.
# (Found on busybox 1.26.0)
(eval '(') 2>/dev/null && _Msh_have FTL_EVALERR "No error exit status from 'eval' on syntax error."

# FTL_ROUNDMLN: AT&T ksh version "M 1993-12-28 s+" (pre-installed version
# on Mac OS X 10.7) has rounding errors in integer arithmetic when ordinary
# shell assignments or comparisons are used on numbers greater than one
# million; only pure shell arithmetic expressions work (up to 64 bits).
# FTL_ARITHASGN: Arithmetic assignment fails if the variable already
# contains a value that cannot be converted to arithmetic. (yash < 2.40)
case " ${_Msh_cap} " in
( *" FTL_NOARITH "* ) ;;  # Skip: not applicable.
( * )	unset -v _Msh_test2
	{ command -v typeset && typeset -i _Msh_test2; } >|/dev/null 2>&1  # suppress ksh93 rendering variable as float exponential
	_Msh_test2=$((1000005))
	_Msh_test=foo\\bar
	( : "$((_Msh_test = 1000005))" ) 2>|/dev/null && : "$((_Msh_test = 1000005))"
	case "${_Msh_test2},$((1000001)),$((1000005)),${_Msh_test}" in
	( 1000005,1000001,1000005,1000005 ) ;;
	( 1000005,1000001,1000005,foo\\bar )
		_Msh_have FTL_ARITHASGN "Arith assignment fails after string assignment. ${YASH_VERSION+(yash 2.40 fixes this)}" ;;
	( 1000010,1e+06,1*00001e+06,1000005 )
		_Msh_have FTL_ROUNDMLN 'Broken shell assignment/comparison: rounding errors after 1 million' ;;
	( * )	_Msh_have FTL_ROUNDNEW "Undiscovered bug in shell arith! (${_Msh_test2},$((1000001)),$((1000005)),${_Msh_test})" ;;
	esac
	unset -v _Msh_test2  # undo typeset -i
	;;
esac

# FTL_NOFNOVER: Can't override shell builtins with shell functions. (ksh88)
{ echo() { :; }; } 2>|/dev/null && unset -f echo || _Msh_have FTL_NOFNOVER "Can't override shell builtins with functions."

# FTL_NOPPID: no $PPID variable (parent's process ID). (NetBSD sh)
case ${PPID-} in
( '' | 0* | *[!0123456789]* )
	_Msh_have FTL_NOPPID 'No $PPID.' ;;
esac

# FTL_ASTERWRD: "$*" (ASTERisk) resolves to multiple WoRDs (i.e. acts
# like "$@") when IFS is empty. This is fatal for scripts using 'safe'.
# (Bug found in zsh 4.3.12 to 4.3.17)
IFS=''
_Msh_testFn2() {
	_Msh_test=$#
}
_Msh_testFn() {
	set -- one two three four
	_Msh_testFn2 "$*"
}
_Msh_testFn
case ${_Msh_test} in
( 1 )	;;
( * )	_Msh_have FTL_ASTERWRD 'Broken "$*", does not yield single word when IFS empty'
esac
IFS=' '

# FTL_SUBSHEXIT: Incorrect exit status within subshells.
# (bash 4.3 and 4.4 compiled without job control)
case " ${_Msh_cap} " in
( *\ FTL_NOCOMMAND\ * )
	;;	# skip: can't use "command"
( * )
	( command -p false && exit 13 || exit 37 )
	_Msh_test=$?	# BUG_CASESTAT compat
	case ${_Msh_test} in
	( 37 )	;;
	( * )	_Msh_have FTL_SUBSHEXIT "Exit status of commands in subshells is broken. (${_Msh_test})" ;;
	esac ;;
esac

# FTL_FNREDIR: I/O redirections on function definition commands are not
# remembered or honoured when the function is executed. (zsh < 5.0.7)
_Msh_testFn() {
	PATH=$DEFPATH [ -t 0 ]
} </dev/tty
_Msh_testFn <&- || _Msh_have FTL_FNREDIR "I/O redir on function defs ignored.${ZSH_VERSION+ (zsh 5.0.7 fixes this)}"

# FTL_ASGNBIERR: Variable assignments preceding regular builtin commands
# should not persist after the command exits, but with this bug they do if
# the command exits with an error. This may break various scripts in obscure
# ways and certainly destroys some modernish feature tests (particularly,
# 'PATH=temp_path builtin_with_error' causes the temporary $PATH to persist!)
# Bug found on AT&T ksh93 version "M 1993-12-28 r".
_Msh_test=ok
_Msh_test=bug command -@ 2>/dev/null	# invalid option triggers error
case ${_Msh_test} in
( bug )	_Msh_have FTL_ASGNBIERR 'Assignments preceding a regular builtin persist if it encounters an error.' ;;
( ok )	;;
( * )	_Msh_have FTL_ASGNBIERR 'Internal error.' ;;
esac

# FTL_UPP (Unset Positional Parameters): Cannot access "$@" or "$*" if set -u
# (-o nounset) is active and there are no positional parameters. If that
# option is set, NetBSD /bin/sh and older versions of ksh93 and pdksh error
# out on accessing "$@" and "$*" (the collective positional parameters), even
# if that access is implicit in a 'for' loop (as in 'for var do stuff; done').
# This is against the standard:
#     "-u: When the shell tries to expand an unset parameter OTHER THAN THE
#     '@' AND '*' SPECIAL PARAMETERS, it shall write a message to standard
#     error and shall not execute the command containing the expansion [...]".
# Reference:
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_25_03
# (under '-u').
if ! ( set -u --; set -- "$@"; _Msh_test=$*; for _Msh_test do :; done; ) 2>| /dev/null
then
	_Msh_have FTL_UPP '"$@"/"$*" error out if they are empty and "set -u" is active.'
fi

# FTL_UNSETFAIL: the 'unset' command sets a non-zero (fail) exit status if
# the variable to unset was either not set (some pdksh versions), or never
# set before (AT&T ksh 1993-12-28). This is contrary to POSIX, which says:
# "Unsetting a variable or function that was not previously set shall not be
# considered an error [...]". Reference:
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_29_03
# To detect this bug on AT&T ksh, use a variable that we're pretty sure was
# never set before in any program in the world, ever ('uuidgen' helped).
unset -v _Msh_FTL_UNSETFAIL_D7CDE27B_C03A_4B45_8050_30A9292BDE74 \
|| _Msh_have FTL_UNSETFAIL "'unset' returns error status on unsetting unset variables."

# FTL_EVALALIAS: aliases aren't expanded in 'eval'
case " ${_Msh_cap} " in
( *\ FTL_NOALIAS\ * ) ;;	# skip: not applicable
( * )	_Msh_testFn() { ! :; }
	alias _Msh_testFn=:
	eval _Msh_testFn || _Msh_have FTL_EVALALIAS "No alias expansion in 'eval'."
	unalias _Msh_testFn ;;
esac

# --- Non-fatal bug tests ---

# BUG_MULTIBYTE: We're running on a locale with a variable-length character
# set (i.e. UTF-8) but the shell does not support multi-byte characters. For
# instance, ${#var} measures length in bytes, not characters. With
# fixed-length one-byte character sets, the bug is irrelevant so we don't
# set the identifier. Current shells with this bug include dash and most
# branches of pdksh.
# Note: Currently, BUG_MULTIBYTE is only detected if we're in a UTF-8 locale.
# (This is the only multibyte locale supported by current shells.)
# It should not be detected for single-byte locales as it's irrelevant there.
# Ref.: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_02
case ${LC_ALL:-${LC_CTYPE:-${LANG:-}}} in
( *.[Uu][Tt][Ff]8 | *.[Uu][Tt][Ff]-8 )
	_Msh_test='bèta' # 4 char, 5 byte UTF-8 string 'beta' with accent grave on 'e'
	case ${#_Msh_test} in
	( 4 )	;;
	( 5 )	_Msh_have BUG_MULTIBYTE ;;
	( * )	_Msh_have FTL_UTFLENGTH "Fatal error in measuring UTF-8 string length. (${#_Msh_test})" ;;
	esac
	# FTL_UTFCASE: shell cannot relibaly compare UTF-8 characters.
	# (found on busybox with CONFIG_LOCALE_SUPPORT enabled)
	case "ρ" in
	( "ρ" )	;;
	( * )	_Msh_have FTL_UTFCASE "'case' cannot relibaly compare UTF-8 chars.
		(If this is busybox, recompile with CONFIG_LOCALE_SUPPORT off)" ;;
	esac ;;
esac

# QRK_IFSFINAL: in field splitting, a final non-whitespace IFS delimiter
# character is counted as an empty field (yash, zsh, pdksh)
# The POSIX standard is pretty ambiguous on this:
# https://osdn.jp/ticket/browse.php?group_id=3863&tid=35283#comment:3863:35283:1435293070
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05
# http://www.mail-archive.com/bug-bash@gnu.org/msg05283.html
# It's a QRK (quirk), not a BUG, because it's not clear that the uncommon
# field splitting behaviour is a POSIX compliance bug, but it's certainly in
# the minority among shells.
#
# Also test for fatal fieldsplitting bugs in other shells. The ones
# involving backslashes would break shellquote() in particular. To make sure
# shellquote() works correctly, also include single quotes in the test.
IFS=': '
_Msh_test='  ::  \on\e :\tw'\''o \th\'\''re\e :\\'\''fo\u\r:   : :  '
_Msh_testFn() {
	IFS=' '	# avoid FTL_SUBSTIFS adding :s to _Msh_cap on old zsh
	case ${#},${1-U},${2-U},${3-U},${4-U},${5-U},${6-U},${7-U},${8-U},${9-U},${10-U},${11-U},${12-U}, in
	( '8,,,\on\e,\tw'\''o,\th\'\''re\e,\\'\''fo\u\r,,,U,U,U,U,' )
		# no quirks or bugs (bash, ash, dash, ksh93, mksh, ...)
		;;
	( '9,,,\on\e,\tw'\''o,\th\'\''re\e,\\'\''fo\u\r,,,,U,U,U,' )
		# zsh, yash
		_Msh_have QRK_IFSFINAL
		;;
	( '11,,,\on\e,,\tw'\''o,\th\'\''re\e,,\\'\''fo\u\r,,,,U,' )
		# pdksh
		_Msh_have QRK_IFSFINAL
		_Msh_have FTL_IFSWHSP "Field splitting: incorrect IFS whitespace removal."
		;;
	( '9,,,on\e,tw'\''o,th\'\''re\e,\'\''fo\u\r,,,,U,U,U,' )
		# yash 2.8 to 2.37
		_Msh_have QRK_IFSFINAL
		_Msh_have FTL_IFSBKSL "Field splitting eats initial backslashes.${YASH_VERSION+ (yash 2.38 fixes this)}"
		;;
	( '9,,,\on\e,\tw'\''o,\th\'\''re\e,\'\''fo\u\r,,,,U,U,U,' )
		# zsh up to 4.2.6
		_Msh_have QRK_IFSFINAL
		_Msh_have FTL_IFSEFODB "Field splitting eats first of double backslash.${ZSH_VERSION+ (zsh 4.2.7 fixes this)}"
		;;
	( '8,,\on\e,\tw'\''o,\th\'\''re\e,\\'\''fo\u\r,,,,U,U,U,U,' )
		# ksh93 Version M 1993-12-28 p
		# Bug with IFS whitespace: an initial empty whitespace-separated field
		# appears at the end of the expansion result instead of the start
		# if IFS contains both whitespace and non-whitespace characters.
		_Msh_have FTL_IFSWHSPE "Split: Initial empty field moved to end of expansion."
		;;
	( '7,::,\on\e,:\tw'\''o,\th\'\''re\e,:\\'\''fo\u\r:,:,:,U,U,U,U,U,' )
		# ksh93 with a DEBUG trap set
		_Msh_have FTL_IFSNONWH "Non-whitespace ignored in field splitting."
		;;
	( '1,  ::  \on\e :\tw'\''o \th\'\''re\e :\\'\''fo\u\r:   : :  ,U,U,U,U,U,U,U,U,U,U,U,' )
		_Msh_have FTL_NOFSPLIT "No field splitting. (Native zsh mode?)"
		;;
	( * )	_Msh_have FTL_IFSNWBUG "Undiscovered quirk or bug with field splitting! Please report. (${#},${1-U},${2-U},${3-U},${4-U},${5-U},${6-U},${7-U},${8-U},${9-U},${10-U},${11-U},${12-U},)"
		;;
	esac
}
_Msh_testFn ${_Msh_test}

# BUG_IFSISSET: From the AT&T ksh93 changelog:
# 13-06-20  A bug in which  ${IFS+abc} did not expand to abc when IFS is
#           unset has been fixed.
# This introduces a bug, it doesn't fix one. The parameter substitution
# ${var+x} is not supposed to expand to anything if 'var' is unset. IFS is not
# special in this regard, and ksh93 as of 2013-06-20 is unique in the POSIX
# world with this behaviour. Even its proprietary 'test -v' (to test if a
# variable is set) is affected. So on recent ksh93, the only way to test if
# IFS is set or not is by analysing the shell's field splitting behaviour.
unset -v IFS
case ${IFS+s} in
( '' )	;;
( s )	_Msh_have BUG_IFSISSET ;;
esac
IFS=' '

# BUG_CMDSPASGN: AT&T ksh93: 'command' fails to make variable assignments
# non-persistent when using 'command' to make a special utility non-special.
# bash 2.05*/3.00.*: same bug but only with 'eval', '.' and 'source' in POSIX
# mode. Test must be here (builtin) to detect on these old bash versions as
# it isn't triggered if the test script is itself sourced from a dot script.
# TODO: reinstate external test for ksh93 when stopping support for bash < 3.1
_Msh_test=BUG_CMDSPASGN command eval
case ${_Msh_test-} in
( BUG_CMDSPASGN )
	_Msh_have BUG_CMDSPASGN ;;
esac

# --- Tests for optional, non-standard, but common features. ---

# Seed the $RANDOM pseudorandom number generator if we have it. In any case, set it
# to read-only to block unsetting/overwriting and using it as a regular variable.
# Modernish library functions depend on it either working properly or being absent.
case ${RANDOM+s},${RANDOM-} in
( s, | s,*[!0123456789]* )
	unset -v RANDOM ;;
( s,* )	# don't discard any seeding the shell may have done: xor our PID
	RANDOM=$((RANDOM ^ $$))
	case $RANDOM,$RANDOM,$RANDOM,$RANDOM in
	( "$RANDOM,$RANDOM,$RANDOM,$RANDOM" )
		unset -v RANDOM ;;
	( * )	_Msh_have RANDOM ;;
	esac ;;
esac
readonly RANDOM

# LOCAL: Function-local variables using the 'local' or 'typeset' special
# builtin or shell keyword on functions defined using POSIX syntax().
if _Msh_testFn() { local _Msh_test || return; _Msh_test=7; } \
&& _Msh_test=42 && _Msh_testFn && case ${_Msh_test} in (42);; (*) ! : ;; esac; then
	_Msh_have LOCAL
elif _Msh_testFn() { typeset _Msh_test || return; _Msh_test=7; } \
&& _Msh_test=42 && _Msh_testFn && case ${_Msh_test} in (42);; (*) ! : ;; esac; then
	# alias it on pdksh/mksh -- and yash, if not in posix mode
	alias local=typeset
	_Msh_have LOCAL
fi 2>|/dev/null

# KSH88FUNC: define ksh-style shell functions with the 'function' keyword,
# supporting local variables with the 'typeset' builtin. 
# KSH93FUNC: the same, but with static scoping for local variables.
# - NOTE: the superflous '()' must NOT be included; ksh93 doesn't accept it.
# - On AT&T ksh93, local variables are ONLY possible on functions defined
#   with the 'function' keyword and by using the 'typeset' builtin.
# This feature test was based on Q28 at http://kornshell.com/doc/faq.html
if command -v typeset && (eval 'function foo { :; }' && typeset foo=bar); then
	eval '
	function _Msh_testFn {
		_Msh_test2=${_Msh_test}
	}
	function _Msh_testFn2 {
		typeset _Msh_test=local || return
		_Msh_testFn
	}' &&
	_Msh_test=global &&
	_Msh_test2='' &&
	_Msh_testFn2 &&
	case ${_Msh_test2} in
	( global ) _Msh_have KSH93FUNC ;;
	( local )  _Msh_have KSH88FUNC ;;
	esac
fi >|/dev/null 2>&1

# --- Control character constants ---

# POSIX does not have a good way to refer to control characters in variable
# assignments or as parameters to arbitrary commands. Let's make this
# convenient using readonly variables (constants) in the CC[017][0-9A-F]
# and CC[a-z] namespaces (CC = control character).
# ATTENTION: LITERAL CONTROL CHARACTERS BELOW. Most editors handle this gracefully.
#
# We cannot have $CC00 because shell variables can't contain the 0 character.
		CC01=''	CC02=''	CC03=''	CC04=''	CC05=''	CC06=''	CC07=''
CC08=''	CC09='	'			CC0B=''	CC0C=''	CC0D=''	CC0E=''	CC0F=''
CC10=''	CC11=''	CC12=''	CC13=''	CC14=''	CC15=''	CC16=''	CC17=''
CC18=''	CC19=''	CC1A=''	CC1B=''	CC1C=''	CC1D=''	CC1E=''	CC1F=''
CC7F=''
# MAKE SURE THE FOLLOWING IS A LITERAL NEWLINE AND NOTHING ELSE.
CC0A='
'
# Make them constants.
readonly     CC01 CC02 CC03 CC04 CC05 CC06 CC07 \
	CC08 CC09 CC0A CC0B CC0C CC0D CC0E CC0F \
	CC10 CC11 CC12 CC13 CC14 CC15 CC16 CC17 \
	CC18 CC19 CC1A CC1B CC1C CC1D CC1E CC1F \
	CC7F || _Msh_have FTL_ROSERIES "'readonly' can't make a series of variables read-only."

# For convenience, provide some synonyms corresponding with 'printf' codes:
# e = escape; a = bell (alarm); b = backspace; f = form-feed; n = new-line;
# r = carriage return; t = tab; v = vertical tab
readonly "CCe=$CC1B" "CCa=$CC07" "CCb=$CC08" "CCf=$CC0C" "CCn=$CC0A" "CCr=$CC0D" "CCt=$CC09" "CCv=$CC0B" 2>/dev/null
# Check that this worked. If not, we have FTL_ROASSIGN.
case $CCe$CCa$CCb$CCf$CCn$CCr$CCt$CCv in
( "$CC1B$CC07$CC08$CC0C$CC0A$CC0D$CC09$CC0B" )
	# The following are handy to use in a glob pattern to check against control characters in a string:
	#	if match "$var" "*[$CONTROLCHARS]*"; then
	#		putln "\$var contains at least one control character"
	#	fi
	# ...or (using '!') for checking against characters *not* part of a particular set:
	#	case $var in
	#	( *[!"$ASCIICHARS"]* )	# (this breaks with FTL_BRACSQBR)
	#		putln "\$var contains at least one non-ASCII character" ;;
	#	esac
	# ...or for field splitting:
	#	IFS="$WHITESPACE,/"  # split fields at any whitespace, comma or slash, with space a primary separator
	# All the control characters:
	readonly "CONTROLCHARS=$CC01$CC02$CC03$CC04$CC05$CC06$CC07$CC08$CC09$CC0A$CC0B$CC0C$CC0D$CC0E$CC0F$CC10$CC11$CC12$CC13$CC14$CC15$CC16$CC17$CC18$CC19$CC1A$CC1B$CC1C$CC1D$CC1E$CC1F$CC7F"
	# All whitespace characters (starts with a space):
	readonly "WHITESPACE= $CCt$CCn$CCv$CCf$CCr"
	# The ASCII uppercase alphabet:
	readonly "ASCIIUPPER=ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	# The ASCII lowercase alphabet:
	readonly "ASCIILOWER=abcdefghijklmnopqrstuvwxyz"
	# All the ASCII alphanumeric characters:
	readonly "ASCIIALNUM=0123456789${ASCIIUPPER}${ASCIILOWER}"
	# Safelist for shell-quoting, good for use in bracket patterns.
	readonly "SHELLSAFECHARS=${ASCIIALNUM}%+,./:=@_^!-"
	# The complete set of ASCII characters, good for use in bracket patterns.
	readonly "ASCIICHARS=${CONTROLCHARS} \"#\$&'()*;<>?[\\\\\\]\`{|}~${SHELLSAFECHARS}"
	;;
( * )	# FTL_ROASSIGN: unpatched pdksh
	_Msh_have FTL_ROASSIGN "'readonly' command doesn't support assignment."
	;;
esac

# SIGPIPESTATUS: harden() and traverse() need to be able to whitelist the exit status of processes killed by
# SIGPIPE, so that (for example) 'gzip -dc textfile.txt | head' won't kill the program if a hardened 'gzip'
# is killed by SIGPIPE. Hence the 'harden -P' option.
# According to POSIX, the numerical value of SIGPIPE is implementation-defined. In addition, different
# shells have different exit status offsets for signals: yash has signum+384, ksh93 has signum+256, the
# rest signum+128. So we have to kill a process with SIGPIPE to find out its exit status.
case $- in
( *m* )	# Slow but reliable method.
	SIGPIPESTATUS=$(exec "$MSH_SHELL" -c 'kill -s PIPE $$ || kill -PIPE $$; echo IGNORED')
	SIGPIPESTATUS=${SIGPIPESTATUS:-$?} ;;
( * )	# Fastest method because 'kill' will normally kill the background job before it even starts running.
	# Use it only with job control disabled to avoid job control clutter on the terminal.
	case ${BASH_VERSION-} in
	( 2.* )	# bash 2 has a race condition with 'wait' that means we need to avoid this method.
		# 'wait' may either exit shell with "Broken pipe" or set exit status to 0.
		_Msh_have BUG_WAITST
		SIGPIPESTATUS=0 ;;
	( * )	"$MSH_SHELL" -c ':' & kill -s PIPE "$!"
		wait "$!"	# acquire exit status from background job
		SIGPIPESTATUS=$? ;;
	esac
	case $SIGPIPESTATUS in
	( ? | ?? | 1[01]? | 12[!9] )
		# - A race condition on some old shells may cause "wait $!" to yield status 0.
		# - An obscure intermittent bug on AT&T ksh93 may cause the exit status of "wait $!" to
		#   be 13 (the value of SIGPIPE without the mandatory offset), depending on the version.
		# - Maybe SIGPIPE is being ignored.
		# Fall back to the simple method for these cases, or any others where $? <= 128.
		SIGPIPESTATUS=$(exec "$MSH_SHELL" -c 'kill -s PIPE $$ || kill -PIPE $$; echo IGNORED')
		SIGPIPESTATUS=${SIGPIPESTATUS:-$?} ;;
	esac ;;
esac 2>/dev/null
case $SIGPIPESTATUS in
( IGNORED )
	_Msh_have WRN_NOSIGPIPE
	SIGPIPESTATUS=99999 ;;
( *[!0123456789]* | ? | ?? | 1[01]? | 12[!9] )
	_Msh_have FTL_SIGPIPEST "Can't determine SIGPIPESTATUS (bad value: $SIGPIPESTATUS)" ;;
esac
readonly SIGPIPESTATUS

# --- End of builtin tests ---
# (actually, tolower()/toupper() may add BUG_CNONASCII later; keep _Msh_have() for now)
case ${_Msh_ftlcount} in
( 0 )	;;
( 1 )	_Msh_initExit "1 fatal shell bug found. This shell can't run modernish." ;;
( * )	_Msh_initExit "${_Msh_ftlcount} fatal shell bugs found. This shell can't run modernish." ;;
esac

# -------------

# Internal functions. Subject to change without notice.

_Msh_dieArgs() {
	die "$1: incorrect number of arguments (was $2, must be $3)"
}

# preliminary isset
isset() {
	eval "case \${$1+s} in ( '' ) return 1 ;; esac"
}

# -------------

# more readable synonym for '!'
alias not='! '		# note: final space = continue to expand aliases

# test preceding command's success with 'if so;' or 'if not so;'
alias so='{ let "$?==0"; }'	# we'll add 'let' to shells without it

# more readable indefinite loops
alias forever='while :;'

# die: Emergency program halt for fatal errors.
# On non-interactive shells, terminate the entire program, including subshells.
# On interactive shells, we can't exit, so attempt to interrupt compound command
# execution, or if that fails, merely return. Hence the need for "|| return".
# Usage: die [ <message> ] || return
unset -v _Msh_die_isrunning
case $- in
( *i* )
	# On an interactive shell, attempt to interrupt command execution (loops, compounds) and return
	# straight to the prompt, by sending SIGINT to the main shell, which is equivalent to pressing
	# Ctrl+C. Note that some shells allow SIGINT to be ignored (using the 'trap' command) even on
	# interactive shells. Since interactive die() may fail for that reason, we still need
	# '|| return' after every 'die' invocation.
	die() {
		case $# in
		( 0 )	;;
		( * )	put "${ME##*/}: ${@}${CCn}" >/dev/tty
			if ! is onterminal 2; then
				put "${ME##*/}: ${@}${CCn}" >&2
			fi ;;
		esac
		if insubshell; then
			# Interrupt main shell, then exit subshell.
			PATH=$DEFPATH command kill -s INT "$$"
			command exit 125
		else
			PATH=$DEFPATH command kill -s INT "$$"
			return 125
		fi
	}
	;;
( * )
	# On a non-interactive shell, execute SIGDIE traps (if any), then kill the program:
	# send SIGKILL to main process plus all its subprocesses (incl. subshells). This should
	# allow terminating a program even from within a subshell.
	#
	# Note that the process group (PID 0) may include not just subprocesses but parent
	# processes as well, e.g. a program that launched this one. We want to kill only
	# subprocesses. So instead of using 'kill -s KILL 0', use 'ps' and 'awk' to
	# recursively find only the subprocesses of $$, excluding DIE trap bg jobs.
	#
	# Determine a couple of things at init time to increase die()'s efficiency:
	# - 'ps' flags that show at least the PPID and PID columns (position/order irrelevant).
	case $(LC_ALL=C PATH=$DEFPATH exec ps -oppid,pid 2>/dev/null) in
	( *PPID*\ PID${CCn}*[0123456789]*\ *[0123456789]* )
		unset -v _Msh_psBroken ;;	# POSIX '-o ppid,pid' (efficient)
	( * )	_Msh_psBroken='-l' ;;		# Cygwin, legacy unix
	esac
	readonly _Msh_psBroken
	die() {
		# Save current exit status for DIE traps.
		_Msh_E=$?
		# Try to prevent loops.
		case ${_Msh_die_isrunning+s} in
		( s )	_Msh_doExit 125 "$@" ;;
		esac
		_Msh_die_isrunning=y
		alias die='_Msh_doExit 125'
		# The program is in an inconsistent/undefined state. For all we know it could be about to
		# delete all your data. Time is of the essence, so execute any and all DIE traps simultaneously.
		# Also print the error message in the background in case output blocks due to redirection.
		# Save the main background job's PID in order to exclude it (and its subprocesses) from being killed,
		# Background jobs are </dev/null by default, which is unwanted for traps, so redirect stdin to a copy of itself.
		# (Preserving stdin allows 'stty' to restore terminal state from a trap.)
		{	case ${_Msh__V_Msh_trapDIE__SP+s} in
			( s )	while let "(_Msh__V_Msh_trapDIE__SP-=1) >= 0"; do
					_Msh_doOneStackTrap DIE "${_Msh__V_Msh_trapDIE__SP}" "${_Msh_E}" 0<&8 &
				done ;;
			esac
			case ${_Msh_POSIXtrapDIE+p} in
			( p )	_Msh_doPosixTrap DIE "${_Msh_E}" 0<&8 & ;;
			esac
			put "${ME##*/} died${1+: $@}$CCn" >/dev/tty
			if ! is onterminal 2; then
				put "${ME##*/} died${1+: $@}$CCn" >&2
			fi
		} 8<&0 &
		_Msh_tPID=$!
		# No need to save any settings now...
		export "PATH=$DEFPATH" LC_ALL=C
		set -o noglob
		unset -f ps awk	# QRK_EXECFNBI compat
		# Issue SIGKILL, which cannot be ignored and won't execute any other traps.
		# Recursively get all this shell's subprocesses with a little help from awk.
		# The awk program's algorithm is inspired by http://superuser.com/a/784102
		if insubshell -p; then
			# We can't exit the main shell from a subshell, so kill both the main shell and its subproccesses.
			# Since this includes the current subshell, use the external 'kill' utility, as the builtin would
			# kill itself before finishing the job! (Therefore, don't 'exec' the external 'kill' utility
			# either, as it would replace this subshell under the same PID and so still kill itself.)
			# We also can't use the 'kill' builtin by simply skipping the PID of the current subshell and then
			# exiting that subshell normally, as this breaks with non-forking subshells (on ksh93).
			#	[ If the main shell no longer exists, we're in a background subshell spawned by the defunct
			#	main shell. The awk program deals specially with this case. We might be in a subshell of (a
			#	subshell of ...) a background subshell, so move up into the process hierarchy until we find the
			#	orphaned (grand)parent, then kill it and all its subprocesses. That's the best we can do.
			#	There is no hope of catching any lateral background subshells spawned by the defunct main
			#	shell, as their association with our process hierarchy has been severed. ]
			IFS=$CCn  # split 'awk' output for 'kill'
			extern kill -s KILL $(exec ps ${_Msh_psBroken:--oppid,pid} | exec awk "
				NR==1 { for (i=1; i<=NF; i++) if (\$i==\"PPID\") pp=i; else if (\$i==\"PID\") p=i }
				NR>1 { subplist[\$pp]=(subplist[\$pp])(\" \")(\$p); parent[\$p]=\$pp }
				END { if (parent[$$]==\"\") getsubpids(bgmain($REPLY)); else getsubpids($$) }
				function bgmain(pid) {
					while (parent[parent[pid]]!=\"\" && parent[parent[pid]]!=parent[pid])
						pid=parent[pid]
					return pid
				}
				function getsubpids(pid,   numsubs, i, subpid) {
					print pid
					numsubs=split(subplist[pid], subpid, \" \")
					for (i=1; i<=numsubs; i++)
						if (subpid[i]!=${_Msh_tPID})
							getsubpids(subpid[i])
				}") 2>/dev/null
		else
			# Kill any subprocesses, then exit the main shell normally.
			IFS=$CCn  # split 'awk' output for 'kill'
			command kill -s KILL $(exec ps ${_Msh_psBroken:--oppid,pid} | exec awk "
				NR==1 { for (i=1; i<=NF; i++) if (\$i==\"PPID\") pp=i; else if (\$i==\"PID\") p=i }
				NR>1 { subplist[\$pp]=(subplist[\$pp])(\" \")(\$p) }
				END { getsubpids($$) }
				function getsubpids(pid,   numsubs, i, subpid) {
					numsubs=split(subplist[pid], subpid, \" \")
					for (i=1; i<=numsubs; i++)
						if (subpid[i]!=${_Msh_tPID})
							{ print subpid[i]; getsubpids(subpid[i]) }
				}") 2>/dev/null
		fi
		command trap - 0  # clear EXIT trap (BUG_TRAPEXIT compat); only DIE traps are executed upon die()
		command exit 125
	}
	;;
esac

# Extended 'exit'. Usage: exit [ -u ] [ <status> [ <message> ] ]
# (Be sure to still respect/restore IFS, etc. as exit traps may be executed after this!)
alias exit=_Msh_doExit
_Msh_doExit() {
	_Msh_exit_status=$?
	case ${1-} in
	( -u )	_Msh_exit_usage=y; shift ;;
	( * )	unset -v _Msh_exit_usage ;;
	esac
	case $# in
	( 0 )	;;
	( * )	case $1 in
		( [0123456789] | [123456789][0123456789] | 1[0123456789][0123456789] | 2[01234][0123456789] | 25[012345] )
			_Msh_exit_status=$1 ;;
		( * )	die "exit: bad exit status: $1" || command exit ;;
		esac
		shift ;;
	esac
	case $# in
	( 0 )	;;
	( * )	put "${ME##*/}: ${@}${CCn}" 1>&2 ;;
	esac
	case ${_Msh_exit_usage+s} in
	( s )	showusage 1>&2 ;;
	esac
	command exit "${_Msh_exit_status}"
}

# Default showusage(). Feel free to override with another one.
showusage() {
	putln "Type ${ME##*/} --help for help."
}

# Manually set exit status ("$?") to the desired value. The canonical method
# is '(exit $status)' but that forks a subshell. Using a function is much
# faster. Don't do validation except for non-negative decimal integer, as
# many shells internally support exit statuses much greater than 255.
setstatus() {
	case ${#},${1} in
	( [!1],* | ?[!,]* )
		_Msh_dieArgs setstatus "$#" 1 || return ;;
	( 1, | 1,*[!0123456789]* )
		die "setstatus: bad exit status: $1" || return ;;
	esac
	return "$1"
}

# Use a modernish module.
# If the module is already loaded, does nothing and exits successfully
# (status 0), preventing dependency loops. The space-separated global
# internal variable _Msh_using keeps track of the modules in use.
_Msh_using=''
use() {
	case ${#},${-} in
	( 0,* )	_Msh_dieArgs use "$#" 'at least 1' || return ;;
	( *a* )	set +a; use "$@"; eval "set -a; return $?" ;;
	esac

	case $1 in
	( '' | *[!"$SHELLSAFECHARS"]* )
		die "use: invalid module name: $1" || return ;;
	esac

	# return gracefully if the module was already loaded
	case " ${_Msh_using} " in
	( *" $1 "* )
		return ;;
	esac

	if ! is -L reg "$MSH_PREFIX/libexec/modernish/$1.mm"; then
		die "use: module $1 not found" || return
	fi

	push _Msh_use_M  # make recursive 'use' possible

	_Msh_use_M=$1
	shift

	_Msh_doUse "$@" || eval "pop _Msh_use_M; die 'use: initialization of module ${_Msh_use_M} failed'" || return

	_Msh_using=${_Msh_using:+${_Msh_using} }${_Msh_use_M}

	isset -i && putln "Using ${_Msh_use_M}"

	pop _Msh_use_M
}
# Wrapping the dot command in its own function works around bugs or quirks
# with 'return' on a couple of shells (yash < 2.44, older FreeBSD sh).
_Msh_doUse() {
	. "$MSH_PREFIX/libexec/modernish/${_Msh_use_M}.mm"
}

# -------------

# **** thisshellhas() ****
# Test if all of the given words are shell keywords, regular or special
# built in commands, shell options, or (for words that are in all caps)
# optional capabilities or bugs that modernish found in the current shell.
#
# Usage: thisshellhas <item> [ <item> ... ]
#        thisshellhas [ --cache | --show ]
#
# If <item> contains only uppercase letter, digits or '_', return the result
# of the associated modernish feature, quirk or bug test.
# If <item> is an all-lowercase word, check if it's a shell reserved word or
# built-in command on the current shell.
# If <item> starts with --rw= or --kw=, check if it's a shell reserved word.
# If <item> starts with --bi=, check if it's a shell built-in command.
# If <item> is '-o' followed by a separate word, check if this shell has a
# long-form shell option by that name.
# If <item> is any other letter or digit preceded by a single '-', check if
# this shell has a short-form shell option by that character.
# --cache: run all external bug/quirk/feature tests and cache the results
# --show: like --cache, but also output all the IDs of positive results, one per line
#
# Feature/quirk/bug tests and shell option checks are cached in a variable
# so repeated checks are not inefficient.

# ** First, some internal functions to support thisshellhas():

# Preliminary function to source a bug/capability test (this will be used
# during initialisation before we have is(), so must use [ for now).
_Msh_doCapTest() {
	unset -v _Msh_test						# guarantee unset variable for testing purposes
	set -- "$MSH_PREFIX/libexec/modernish/cap/$1.t"			# this can be used by test scripts as well
	PATH=$DEFPATH command test -f "$1"
	case $? in
	( 0 )	. "$1" 1>&2 ;;
	( 1 )	return 127 ;;
	( * )	die "thisshellhas: doCapTest: 'test' failed" || return ;;
	esac
}
# Pre-cache the results of all the external capability/bug tests.
_Msh_cacheCap() {
	case ${_Msh_cap} in
	( '#ALLCACHED '* )
		if identic "${1-}" '--show'; then
			push IFS -f
			IFS=' '; set -f
			putln ${_Msh_cap#?ALLCACHED}
			pop IFS -f
		fi
		return ;;	# already done
	esac
	push IFS -f _Msh_c _Msh_newCap
	# do any external tests that haven't already been done
	IFS=''; set +f
	for _Msh_c in "$MSH_PREFIX"/libexec/modernish/cap/*.t; do
		_Msh_c=${_Msh_c##*/}
		_Msh_c=${_Msh_c%.t}
		case " ${_Msh_cap} " in
		( *" ${_Msh_c} "* | *" !${_Msh_c} "* ) continue ;;
		esac
		thisshellhas "${_Msh_c}"
	done
	# eliminate negative test results; they are redundant with #ALLCACHED tag
	_Msh_newCap=''
	IFS=' '; set -f
	for _Msh_c in ${_Msh_cap}; do
		case ${_Msh_c} in
		( !* ) continue ;;
		esac
		_Msh_newCap=${_Msh_newCap:+${_Msh_newCap} }${_Msh_c}
	done
	identic "${1-}" '--show' && putln ${_Msh_newCap}
	_Msh_cap="#ALLCACHED ${_Msh_newCap}"
	pop IFS -f _Msh_c _Msh_newCap
}

# ** Shell-specific code for thisshellhas():

# POSIX does not allow for a reliable way to find out what is a shell
# keyword or built in command, but it's essential for feature testing, so
# we have to make do with various shell-specific versions.

if isset BASH_VERSION && builtin shopt -s lastpipe
then
	# The LEPIPEMAIN capability (as of bash 4.2) needs to be tested for as a special
	# case, because bash only has this capability if 'shopt -s lastpipe' is active
	# *and* 'set -m' (job control) is *not* active, and either of those options may
	# be set or unset during the course of a program. The presence of this special
	# test is harmless on earlier versions of bash; it always returns false.
	_Msh_tSH_bashLEPIPEMAIN='( LEPIPEMAIN )
			case $- in
			( *m* )	return 1 ;;
			( * )	if builtin shopt -p lastpipe >/dev/null 2>&1; then
					case " ${_Msh_cap} " in
					( *" LEPIPEMAIN "* ) ;;
					( * ) _Msh_cap=${_Msh_cap:+${_Msh_cap} }LEPIPEMAIN ;;
					esac
				else
					return 1
				fi ;;
			esac
			;;'
else
	_Msh_tSH_bashLEPIPEMAIN=''
fi >/dev/null 2>&1

if isset BASH_VERSION && builtin compgen -k
then
	# Version for bash (but not bash compiled with 'minimal configuration'). The
	# 'compgen' builtin easily lists all keywords (-k) and special/regular builtins
	# (-b). Store them in cache variables so that subsequent invocations of
	# thisshellhas() don't require forking command substitution subshells.
	readonly "_Msh_biCache=$(builtin compgen -b)" "_Msh_kwCache=$(builtin compgen -k)"
	_Msh_tSH_testBI='case $CCn${_Msh_biCache}$CCn in
			( *"$CCn${1#--bi=}$CCn"* ) ;;
			( * )	return 1 ;;
			esac'
	_Msh_tSH_testKW='case $CCn${_Msh_kwCache}$CCn in
			( *"$CCn${1#--[rk]w=}$CCn"* ) ;;
			( * )	return 1 ;;
			esac'
elif isset ZSH_VERSION && builtin enable -r
then
	# Version for zsh, using the same strategy as bash with compgen. 'enable -r' prints all
	# keywords (reserved words), just 'enable' prints all special and regular builtins.
	readonly "_Msh_biCache=$(builtin enable)" "_Msh_kwCache=$(builtin enable -r)"
	_Msh_tSH_testBI='case $CCn${_Msh_biCache}$CCn in
			( *"$CCn${1#--bi=}$CCn"* ) ;;
			( * )	return 1 ;;
			esac 2>/dev/null'	# suppress huge trace if set -x
	_Msh_tSH_testKW='case $CCn${_Msh_kwCache}$CCn in
			( *"$CCn${1#--[rk]w=}$CCn"* ) ;;
			( * )	return 1 ;;
			esac 2>/dev/null'	# suppress huge trace if set -x
elif isset YASH_VERSION && {
	PATH=$DEFPATH command test -o posix
	case $? in
	( 0 )	set +o posix; command -vkb if && set -o posix || ! set -o posix ;;
	( 1 )	command -vkb if ;;
	( * )	false ;;
	esac
}; then
	# Version for yash. 'command -v --keyword' (-vk) and 'command -v --builtin-command'
	# (-vb) do just what we want, but only if posix mode is off.
	_Msh_tSH_testBI='if PATH=$DEFPATH command test -o posix; then
				set +o posix
				command -vb -- "${1#--bi=}" || { set -o posix; return 1; }
				set -o posix
				# yash in POSIX mode checks builtins against $PATH, so recheck
				command -v "${1#--bi=}" || return 1
			else
				command -vb -- "${1#--bi=}" || return 1
			fi >/dev/null'
	_Msh_tSH_testKW='if PATH=$DEFPATH command test -o posix; then
				set +o posix
				command -vk -- "${1#--[rk]w=}" || { set -o posix; return 1; }
				set -o posix
			else
				command -vk -- "${1#--[rk]w=}" || return 1
			fi >/dev/null'
elif case " ${_Msh_cap} " in
     ( *' KSH93FUNC '* ) ;;
     ( * ) false ;;
     esac \
&& ( eval '[[ -n ${.sh.version+s} ]]' )
then
	# Version for ksh93.
	# The 'builtin' command lists all the builtins so we can cache them
	# (which is nice, because BUG_FNSUBSH on ksh93 kills the default method).
	# Some builtins have paths starting with path names and are only used
	# if the (not necessarily existent!) directory is in $PATH.
	# There is no way to list shell keywords, so use the default technique for those.
	readonly "_Msh_biCache=$(builtin)"
	_Msh_kwCache=
	_Msh_kwOutput=$(command -V 'while')
	readonly "_Msh_kwOutput=${_Msh_kwOutput#*while}"	# remove the keyword itself
	_Msh_tSH_testBI='case $CCn${_Msh_biCache}$CCn in
			( *"$CCn${1#--bi=}$CCn"* ) ;;
			( *"/${1#--bi=}$CCn"* )
				# Found builtin with path name. Isolate the "directory" and check $PATH.
				_Msh_tSH_D=${_Msh_biCache}${CCn}
				_Msh_tSH_D=${_Msh_tSH_D%%/${1#--bi=}${CCn}*}
				_Msh_tSH_D=${_Msh_tSH_D##*${CCn}}
				case :$PATH: in
				( *":${_Msh_tSH_D}:"* | *":${_Msh_tSH_D}/:"* )
					unset -v _Msh_tSH_D ;;
				( * )	unset -v _Msh_tSH_D; return 1 ;;
				esac ;;
			( * )	return 1 ;;
			esac'
	_Msh_tSH_testKW='case "${_Msh_kwCache} " in
			( *" ${1#--[rk]w=} "* ) ;;
			( *" !${1#--[rk]w=} "* ) return 1 ;;
			( * )	case $(command -V "${1#--[rk]w=}" 2>/dev/null) in
				( *"${_Msh_kwOutput}" )
					_Msh_kwCache="${_Msh_kwCache} ${1#--[rk]w=}" ;;
				( * )	_Msh_kwCache="${_Msh_kwCache} !${1#--[rk]w=}"
					return 1 ;;
				esac
			esac'
else
	# Generic/default version. As far as I know, this version works on all other shells;
	# at least dash, Busybox ash, FreeBSD /bin/sh, {pd,m}ksh.
	_Msh_biCache=
	_Msh_kwCache=
	# Distinguish a keyword from a builtin by checking against 'command -V' output of a POSIX keyword.
	_Msh_kwOutput=$(command -V 'while')
	readonly "_Msh_kwOutput=${_Msh_kwOutput#*while}"	# remove the keyword itself
	_Msh_tSH_testBI='thisshellhas "--rw=${1#--bi=}" && return 1
			case "${_Msh_biCache} " in
			( *" ${1#--bi=} "* )	;;
			( *" !${1#--bi=} "* )	return 1 ;;
			( * )	_Msh_biCache=${_Msh_biCache}\ $(
					unalias -- "${1#--bi=}" 2>/dev/null
					unset -f -- "${1#--bi=}" 2>/dev/null
					PATH=/dev/null
					command -v -- "${1#--bi=}") \
				|| {
					_Msh_biCache=${_Msh_biCache}!${1#--bi=}
					return 1
				} ;;
			esac'
	_Msh_tSH_testKW='case "${_Msh_kwCache} " in
			( *" ${1#--[rk]w=} "* )	;;
			( *" !${1#--[rk]w=} "* ) return 1 ;;
			( * )	case $(command -V "${1#--[rk]w=}" 2>/dev/null) in
				( *"${_Msh_kwOutput}" )
					_Msh_kwCache="${_Msh_kwCache} ${1#--[rk]w=}" ;;
				( * )	_Msh_kwCache="${_Msh_kwCache} !${1#--[rk]w=}"
					return 1 ;;
				esac
			esac'
fi >/dev/null 2>&1

# ** Main function. Insert the above-determined shell-specific code into it.

_Msh_optCache=
eval 'thisshellhas() {
	case ${#},${-} in
	( 0,* )	_Msh_dieArgs thisshellhas "$#" "at least 1" || return ;;
	( *a* )	set +a; thisshellhas "$@"; eval "set -a; return $?" ;;
	esac
	while :; do
		case $1 in
		( --cache )
			_Msh_cacheCap
			;;
		( --show )
			_Msh_cacheCap --show
			;;
		( "" | --bi= | --[rk]w= | --bi=*/* | --[rk]w=*/* \
		| --bi=*[!\[\]\!{}"$SHELLSAFECHARS"]* \
		| --[rk]w=*[!\[\]\!{}"$SHELLSAFECHARS"]* \
		| --sig=*[!"$SHELLSAFECHARS"]* )
			return 2  # invalid identifier
			;;
		( --bi=* )
			'"${_Msh_tSH_testBI}"'
			;;
		( --[rk]w=* )
			'"${_Msh_tSH_testKW}"'
			;;
		( --sig=* )
			if _Msh_arg2sig "${1#--sig=}" -nv; then
				REPLY=${_Msh_sig}
				unset -v _Msh_sig
			else
				unset -v _Msh_sig REPLY
				return 1
			fi ;;
		( --* )	die "thisshellhas: invalid option: ${1%%=*}" || return
			;;
		( -o )	case ${2-} in
			( allexport | errexit | ignoreeof | noclobber \
			| noglob | noexec | nounset | verbose | xtrace )
				;;
			( "" | *[!"$ASCIIALNUM"_-]* | -* )
				return 2 ;;
			( * )	case " ${_Msh_optCache} " in
				( *" $2 "* )	;;
				( *" !$2 "* )	return 1 ;;
				( * )	if (set +o "$2") 2>/dev/null; then
						_Msh_optCache=${_Msh_optCache:+${_Msh_optCache} }$2
					else
						_Msh_optCache=${_Msh_optCache:+${_Msh_optCache} }!$2
						return 1
					fi ;;
				esac ;;
			esac
			shift ;;
		( -[aCefmnuvx] )
			;;
		( -["$ASCIIALNUM"] )
			case " ${_Msh_optCache} " in
			( *" $1 "* )	;;
			( *" !$1 "* )	return 1 ;;
			( * )	if isset "$1" || (set "+${1#-}") 2>/dev/null; then
					_Msh_optCache=${_Msh_optCache:+${_Msh_optCache} }$1
				else
					_Msh_optCache=${_Msh_optCache:+${_Msh_optCache} }!$1
					return 1
				fi ;;
			esac ;;
		( -* )	return 2 ;;
		( *[!ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_]* )
			thisshellhas "--bi=$1" || thisshellhas "--rw=$1" || return
			;;
		'"${_Msh_tSH_bashLEPIPEMAIN}"'
		( * )	case " ${_Msh_cap} " in
			( *" $1 "* )	;;
			( *" !$1 "* | *" #ALLCACHED "* ) return 1 ;;
			( * )	_Msh_doCapTest "$1"
				case $? in
				( 0 )	_Msh_cap=${_Msh_cap:+${_Msh_cap} }$1
					unset -v _Msh_test ;;
				( 1 | 127 )	# 127 = *.t file not found
					_Msh_cap=${_Msh_cap:+${_Msh_cap} }!$1
					unset -v _Msh_test
					return 1 ;;
				( * )	die "thisshellhas(): failure while testing for $1" || return ;;
				esac ;;
			esac
			;;
		esac
		shift
		case $# in
		( 0 )	break ;;
		esac
	done
}'"${CCn}" || _Msh_initExit "thisshellhas() definition: 'eval' failed"
unset -v _Msh_tSH_testBI _Msh_tSH_testKW _Msh_tSH_bashLEPIPEMAIN

# extern: Run an external command without having to know its exact location,
# even if a built-in command, alias or shell function by that name exists.
# Usage: extern [ -p ] <command> [ <argument> ... ]
#	 extern -v [ -p ] <command> [ <command> ... ]
#	 -p: use system default PATH instead of current PATH, akin to
#	     'command -p' but never uses builtins.
#	 -v: show pathnames of the <command>(s).
# Note that this is a subshell function.
extern() (
	IFS=':'; set -f -u +a	# safe-ish mode, split on $PATH separator
	unset -v _Msh_v _Msh_p
	while	case ${1-} in
		( -p )	_Msh_p=$DEFPATH ;;
		( -v )	_Msh_v='' ;;
		( -pv | -vp ) _Msh_p=$DEFPATH; _Msh_v='' ;;
		( -- )	shift; break ;;
		( -* )	die "extern: invalid option: $1" || return ;;
		( * )	break ;;
		esac
	do
		shift
	done
	case $# in
	( 0 )	die "extern: command expected" || \exit ;;
	esac
	case ${_Msh_v+s} in
	( s )	# -v: check and show command(s)
		_Msh_e=0
		for _Msh_c do
			case ${_Msh_c} in
			( */* )	if can exec "${_Msh_c}"; then
					putln "${_Msh_c}"
					continue
				fi ;;
			( * )	for _Msh_d in ${_Msh_p-$PATH}; do
					if can exec "${_Msh_d}/${_Msh_c}"; then
						putln "${_Msh_d}/${_Msh_c}"
						continue 2
					fi
				done ;;
			esac
			_Msh_e=1
		done
		\exit ${_Msh_e} ;;
	esac
	# not -v: run command
	case $1 in
	( */* )	exec "$@" ;;
	esac
	for _Msh_d in ${_Msh_p-$PATH}; do
		if can exec "${_Msh_d}/$1"; then
			exec "${_Msh_d}/$@"
		fi
	done
	putln "${ME##*/}: extern: command not found: $1" 1>&2
	\exit 127
)

# -------------

# insubshell: Check if we're currently running in a subshell.
# Usage:	insubshell [ -p ]
# Returns with status 0 if we're in a subshell, 1 if not.
# If -p is given, leaves the PID of the current (sub)shell in $REPLY.
#
# Generic, slow version. We must exec a shell to get it to report our PID back to us.
# If modernish was installed properly, $MSH_SHELL is a known-good shell with $PPID.
_Msh_inSbSh_generic_part1='_Msh_inSbSh_P=$(exec "$MSH_SHELL" -c "set -o nounset && echo \$PPID" 2>/dev/null) \
	&& case ${_Msh_inSbSh_P} in ("" | *[!0123456789]*) ! : ;; esac \
	|| _Msh_inSbSh_P=$(PATH=$DEFPATH exec /bin/sh -c '\''ppid=`ps -o ppid= -p $$` && echo $ppid'\'')
	case ${#},${_Msh_inSbSh_P} in
	( ?,"" | ?,*[!0123456789]* )
		putln "${ME##*/}: insubshell: internal error: cannot determine parent PID" 1>&2
		isset _Msh_die_isrunning && return 0 || die ;;'
_Msh_inSbSh_generic_part2='
	( "0,$$" ) unset -v _Msh_inSbSh_P; return 1 ;;
	( "1,$$" ) REPLY=$$; unset -v _Msh_inSbSh_P; return 1 ;;
	( 0,* )    unset -v _Msh_inSbSh_P; return 0 ;;
	( 1,* )    REPLY=${_Msh_inSbSh_P}; unset -v _Msh_inSbSh_P; return 0 ;;
	esac'
# Try to determine an efficient shell-specific version.
if isset BASHPID &&
	_Msh_test=$BASHPID &&
	case $(command trap 'command -p echo "$((BASHPID != _Msh_test))"' EXIT;
		command -p echo "$((BASHPID != _Msh_test))") in
	("1${CCn}1")	;;
	( * )		unset -v BASHPID || _Msh_initExit "can't unset non-working BASHPID!"
			! : ;;
	esac
then	# bash 4 and mksh
	# note inverted comparison: true = 1 = return false
	_Msh_inSbSh_method='case $# in ( 1 ) return "$(((REPLY = BASHPID) == $$))" ;; esac
		return "$((BASHPID == $$))"'
elif isset ZSH_VERSION && isset ZSH_SUBSHELL &&
	_Msh_test=$ZSH_SUBSHELL &&
	case $(command trap 'command -p echo "$((ZSH_SUBSHELL != _Msh_test))"' EXIT;
		command -p echo "$((ZSH_SUBSHELL != _Msh_test))") in
	("1${CCn}1")	;;
	( * )		unset -v ZSH_SUBSHELL || _Msh_initExit "can't unset non-working ZSH_SUBSHELL!"
			! : ;;
	esac
then	# zsh: $ZSH_SUBSHELL can tell us whether we're in a subshell, but not its PID, so fall back to generic for that.
	_Msh_inSbSh_method='case ${#},${ZSH_SUBSHELL} in
		( 0,0 ) return 1 ;;
		( 0,* ) return 0 ;;
		( 1,0 ) REPLY=$$; return 1 ;;
		esac
		'"${_Msh_inSbSh_generic_part1}"'
		esac
		REPLY=${_Msh_inSbSh_P}; unset -v _Msh_inSbSh_P'
elif thisshellhas KSH93FUNC && (eval ': ${.sh.subshell}') 2>/dev/null; then
	# AT&T ksh93. It usually[*] does non-background subshells without forking a new process, so the default
	# version won't work correctly. It has an internal ${.sh.subshell} counter that is increased each time
	# a subshell is entered. Unfortunately it has a bit of a problem: it gets reset to zero if the subshell
	# is created by forking a new process (e.g. a background job)! However, that *is* a separate process so
	# we can use the default method for that case.
	# [*] A quirk on ksh93 is that output redirection (e.g. 1>&2) within a $(command substitution) subshell
	#     causes that subshell to be forked as a separate process, which also resets ${.sh.subshell} to 0.
	_Msh_inSbSh_method='(($# == 0 && .sh.subshell > 0)) && return 0
		'"${_Msh_inSbSh_generic_part1}"'
		( "0,$$" ) unset -v _Msh_inSbSh_P; return 1 ;;
		( "1,$$" ) REPLY=$$; unset -v _Msh_inSbSh_P; return $((.sh.subshell == 0)) ;;
		( 0,* )    unset -v _Msh_inSbSh_P; return 0 ;;
		( 1,* )    REPLY=${_Msh_inSbSh_P}; unset -v _Msh_inSbSh_P; return 0 ;;
		esac'
else	# No shell-specific version available.
	_Msh_inSbSh_method=${_Msh_inSbSh_generic_part1}${_Msh_inSbSh_generic_part2}
fi
eval 'insubshell() {
	case ${#},${1-} in
	( 1,-p )  ;;
	( [!0]* ) die "insubshell: invalid arguments: $@" || return ;;
	esac
	'"${_Msh_inSbSh_method}"'
}'
unset -v _Msh_inSbSh_generic_part1 _Msh_inSbSh_generic_part2 _Msh_inSbSh_method

# Unconditionally make these names read-only, in order to:
# - reserve the names on shells without this functionality, to avoid cross-platform compatibility problems
# - disallow unsetting BASHPID on bash > 4.4.0, which would break insubshell() and lots of other stuff with it
# - enforce failure on assignment, instead of assignments having no effect, for BASHPID on bash > 4.4.0
#   (but note: bash still does not output any error message on assigning to a read-only BASHPID; instead,
#   it exits silently).
readonly BASHPID ZSH_SUBSHELL

# -------------

# Test if argument is valid portable variable (or shell function) name.
# Deals with empty removal. (This is why it doesn't take more than one argument.)
isvarname() {
	case ${#},${1-} in
	( [!01],* | ?[!,]* )
		_Msh_dieArgs isvarname "$#" '0 or 1' ;;
	( [01], | 1,[0123456789]* | 1,*[!"$ASCIIALNUM"_]* )
		return 1 ;;
	esac
}

# isset: Check if a variable, shell function or shell option is set.
# Usage: isset <varname>	# check if variable is set
#	 isset -v <varname>	# id.
#	 isset -x <varname>	# check if variable is exported
#	 isset -r <varname>	# check if variable is read-only
#	 isset -f <funcname>	# check if shell function is set
#	 isset -<optionletter>	# e.g. isset -C: check if shell option is set
#	 isset -o <optionname>	# check if shell option is set by long name
# This function deliberately does not check for nonexistent shell options, but
# instead returns a negative for a nonexistent option; this facilitates
# cross-platform scripting.
# (Note: just 'isset -f' checks if shell option -f (= -o noglob) is set, but
# with an extra argument, it checks if a shell function is set. Empty
# removal is an issue here if that argument is an empty unquoted variable,
# even under 'use safe'. An alternate syntax like isset --fn=<funcname>
# would be safer, but that's an ugly inconsistency with standard 'unset -f
# <funcname>'... As the current isset() syntax is nicely analogous with both
# 'set' and 'unset', I'm thinking we can put up with this minor issue.)
if thisshellhas BUG_IFSISSET; then
	# Workaround for BUG_IFSISSET in recent AT&T ksh93. For some reason they've made it impossible
	# to distinguish in any normal way between empty IFS and unset IFS. But this applies only to
	# IFS and no other variable, so we can figure it out by analysing field splitting behaviour.
	# No field splitting means empty IFS and default field splitting means unset IFS.
	_Msh_isset_BUG_IFSISSET='( 1,IFS, | 2,-v,IFS )			# BUG_IFSISSET workaround:
		case ${IFS:+n} in		# non-empty: it is set
		( "" )	set -- "a b"		# empty: test for default field splitting
			set -- $1
			let "$# == 1"		# no field splitting: it is empty and set
		esac ;;'
else
	_Msh_isset_BUG_IFSISSET=
fi
# ...isset -v
if thisshellhas --rw=[[; then
	if ( eval '[[ -v MSH_VERSION ]]' ) 2>/dev/null; then
		_Msh_isset='[[ -v $1 ]]'
		_Msh_isset_v='[[ -v $2 ]]'
	else
		_Msh_isset='eval "[[ -n \${$1+s} ]]"'
		_Msh_isset_v='eval "[[ -n \${$2+s} ]]"'
	fi
else
	# default (POSIX) version
	_Msh_isset='eval "case \${$1+s} in ( '\'''\'' ) return 1 ;; esac"'
	_Msh_isset_v='eval "case \${$2+s} in ( '\'''\'' ) return 1 ;; esac"'
fi
# ...isset -x and isset -r
if isset ZSH_VERSION && ( eval ': ${(t)PATH}' ) 2>/dev/null; then
	# zsh makes this trivial: ${(t)VARNAME} (dash-separated) contains 'export', and
	# the P in ${(Pt)1} means: use the variable name stored in $1. Good thing too,
	# because 'export' on zsh is a reserved word we cannot alias (see below).
	#
	# Unfortunately, this does not work for unset readonly variables (zsh 5.0.8+) or unset exported
	# variables (zsh 5.3+), which only exist with POSIXBUILTINS active. Must have fallback for that.
	# For readonly, fall back to the simple assignment-in-subshell method. Exported unset variables
	# require examining the output 'export -p'. Thankfully, on zsh, 'export -p' quotes newlines and
	# always outputs one line per variable, so we can do the equivalent of simple grepping.
	_Msh_isset_x='case ${(P)2+s} in
		( s )	contains "-${(Pt)2}-" -export- ;;
		( * )	contains "$(export -p)$CCn" " $2$CCn" ;;
		esac'
	_Msh_isset_r='case ${(P)2+s} in
		( s )	contains "-${(Pt)2}-" -readonly- ;;
		( * )	! ( eval "$2=" ) 2>/dev/null ;;
		esac'
elif ! thisshellhas --rw=export; then
	# On other shells, we must use trickery to reliably parse the output of 'export -p'.
	# The 'export -p' command in POSIX shells produces 'export' commands (even on bash, as
	# long as the shell is in POSIX mode, which it must be to run modernish). Grepping this
	# output is not reliably possible because entries may be split in multiple lines. We
	# must get the shell to parse it. The only way to do this is to temporarily alias
	# 'export' to a handler function. This only works if 'export' is not a reserved word.
	_Msh_isset_x='unset -v _Msh_issetEx_WasRun _Msh_issetEx_FoundIt
		export "_Msh_issetExV=$2"	# guarantee one exported variable to check if this method works
		alias export=_Msh_issetExHandleExport
		eval "$(command export -p)"
		unalias export
		unset -v _Msh_issetExV
		isset _Msh_issetEx_WasRun && unset -v _Msh_issetEx_WasRun ||
			die "isset -x: internal error: '\''export -p'\'' not parseable or '\''export'\'' not aliasable" || return
		isset _Msh_issetEx_FoundIt && unset -v _Msh_issetEx_FoundIt'
	_Msh_issetExHandleExport() {
		_Msh_issetEx_WasRun=''
		case ${1%%=*} in
		("${_Msh_issetExV}") _Msh_issetEx_FoundIt='' ;;
		esac
	}
	# To find out if a variable is read-only, simply try to assign to it in a subshell.
	# (Avoiding a subshell with 'command eval' is too fraught with problems and causes dash/ash to crash.)
	_Msh_isset_r='! ( eval "$2=" ) 2>/dev/null'
else
	_Msh_initExit "init: isset -x: Can't determine method to test if a var. is exported." \
		"This shell has 'export' as a reserved word, but modernish was only" \
		"programmed to handle this on zsh. Please report this as a bug in modernish."
fi
# ...isset -f
if thisshellhas --bi=typeset &&
	command typeset -f isset >/dev/null 2>&1 &&
	! command typeset -f _Msh_nonExistentFunction >/dev/null 2>&1
then
	# bash, zsh, ksh93, mksh/pdksh, yash all have a 'typeset -f' that
	# returns with exit status 0 if the function is set, 1 if not.
	_Msh_isset_f='command typeset -f "$2" >/dev/null 2>&1'
elif ! thisshellhas ROFUNC; then
	# Default (POSIX): compare output of 'command -V' without and with unsetting function.
	# - Expensive test: forks a subshell. This can't be avoided. In fact the straightforward method
	#   involves forking two command substitution subshells and comparing their output. Forking just
	#   one requires a hack involving a separator string, shell parameter substitutions, and defeating
	#   the command substitution's stripping of final linefeeds using a protector character (X).
	# - Using 'unset -f' in a subshell is not BUG_FNSUBSH (ksh93) compatible, but ksh93
	#   has 'typeset -f', so no problem. We could test for the bug here to be extra sure:
	#	! thisshellhas BUG_FNSUBSH || _Msh_initExit 3 'Fatal: BUG_FNSUBSH detected' || return
	#   but forking another init subshell for the BUG_FNSUBSH test hardly seems worth it.
	# - In the hypothetical event of a shell with 'readonly -f' (ROFUNC) but no 'typeset -f',
	#   the following method would produce false negatives for readonly functions. There is no
	#   current shell with that configuration, though.
	_Msh_isset_f='{
		_Msh_isset_fn=$(PATH=/dev/null	# Stop "tracked aliases" causing differing output i.e. false positives.
			command unalias "$2"
			set +x			# xtrace would interfere with the comparison.
			command -V "$2" 2>&1	# Compare everything, even error messages written to stderr.
			PATH=$DEFPATH command echo @_SEP_@
			unset -f "$2"
			command -V "$2" 2>&1
			PATH=$DEFPATH command echo X)
		} 2>/dev/null \
		&& ! identic "${_Msh_isset_fn%@_SEP_@$CCn*}X" "${_Msh_isset_fn#*@_SEP_@$CCn}" \
		&& unset -v _Msh_isset_fn \
		|| ! unset -v _Msh_isset_fn'
else
	_Msh_initExit "Fatal: we don't have a good method for 'isset -f'!" \
		"${CCt}(This shell has 'readonly -f' (ROFUNC) but not 'typeset -f')" \
		"${CCt}Please report this as a bug in modernish."
fi
# ...isset -o
if thisshellhas --rw=[[; then
	if ! ( [[ -o invalid@option ]] || : ) 2>/dev/null; then
		# Shell exits on invalid [[ -o option ]] (zsh).
		_Msh_isset_o='( 2,-o,* ) thisshellhas -o "$2" && [[ -o $2 ]]'
	else
		_Msh_isset_o='( 2,-o,* ) [[ -o $2 ]]'
	fi
elif thisshellhas TESTO; then
	_Msh_isset_o='( 2,-o,* ) test -o "$2"'	# modernish hardened test()
else
	# Default (POSIX): compare output of 'set -o' with and without setting option.
	# - Expensive test: forks a subshell. This can't be avoided. In fact the straightforward method
	#   involves forking two command substitution subshells and comparing their output. Forking just
	#   one requires a hack involving a separator string, shell parameter substitutions, and defeating
	#   the command substitution's stripping of final linefeeds using a protector character (X).
	# - We're relying on 'set -o' output never containing "@_SEP_@"+newline,
	#   but that should be pretty safe as that's not a valid option name.
	# But first hand-map a few common long options to their short equivalents as an optimisation.
	_Msh_isset_o='( 2,-o,allexport )	isset -a ;;
	( 2,-o,interactive )	isset -i ;;
	( 2,-o,monitor )	isset -m ;;
	( 2,-o,noclobber )	isset -C ;;
	( 2,-o,noglob )		isset -f ;;
	( 2,-o,notify )		isset -b ;;
	( 2,-o,nounset )	isset -u ;;
	( 2,-o,verbose )	isset -v ;;
	( 2,-o,xtrace )		isset -x ;;
	( 2,-o,* ) { _Msh_isset_o=$(set -o
				command -p echo @_SEP_@
				set +o "$2"		# subshell errors out here if opt does not exist
				set -o
				command -p echo X)
		} 2>/dev/null \
		&& ! identic "${_Msh_isset_o%@_SEP_@$CCn*}X" "${_Msh_isset_o#*@_SEP_@$CCn}" \
		&& unset -v _Msh_isset_o \
		|| ! unset -v _Msh_isset_o'
fi
# ...with all the code pieced together, define isset()
eval 'isset() {
	case ${#},${1-},${2-} in
	( 1,-o, )  die "isset -o: long-form option name expected" ;;
	( 1,-["$ASCIIALNUM"], )
		   case $- in ( *"${1#-}"* ) ;; ( * ) return 1 ;; esac ;;
	( 1,, | 1,[0123456789]* | 1,*[!"$ASCIIALNUM"_]*, \
	| 2,-[vxrf], | 2,-[vxrf],[0123456789]* | 2,-[vxrf],*[!"$ASCIIALNUM"_]* \
	| 2,-o,? | 2,-o,*[!"$ASCIIALNUM"_-]* )
		   return 2 ;;  # invalid identifier
	'"${_Msh_isset_BUG_IFSISSET}"'
	( 1,* )    '"${_Msh_isset}"' ;;
	( 2,-v,* ) '"${_Msh_isset_v}"' ;;
	( 2,-x,* ) '"${_Msh_isset_x}"' ;;
	( 2,-r,* ) '"${_Msh_isset_r}"' ;;
	( 2,-f,* ) '"${_Msh_isset_f}"' ;;
	'"${_Msh_isset_o}"' ;;
	( 2,-* )   die "isset: invalid option: $2. Usage: isset [ -vxrfo ] NAME" ;;
	( * )	   die "isset: invalid arguments. Usage: isset [ -vxrfo ] NAME" ;;
	esac
}'"$CCn"
unset -v _Msh_isset_BUG_IFSISSET _Msh_isset _Msh_isset_v _Msh_isset_x _Msh_isset_r _Msh_isset_f _Msh_isset_o

# unexport: the opposite of export.
# Clear the 'export' bit of a variable, conserving its value, or assign
# variables without the export bit even if 'set -a' (allexport) is active.
# This allows an "export all variables, except these" way of working. Unlike
# 'export', 'unexport' does not (and cannot) work for read-only variables.
# Usage: like 'export'. (However, unlike 'export' in some shells, there
# is no protection against field splitting or pathname expansion! But
# with 'export' you can't rely on that anyway if you work cross-platform.
# So appropriate shell-quoting is necessary if you pass an assignment.)
#
if isset YASH_VERSION && command typeset --unexport _Msh_test; then
	# yash has 'typeset --unexport'.
	# (Just to be sure, let's not use the short option equivalent 'typeset -X'
	# as it has a very different meaning on recent versions of ksh93!)
	# Still do validation, because yash's 'typeset' silently ignores crazy stuff.
	unexport() {
		case $# in
		( 0 )	_Msh_dieArgs unexport "$#" 'at least 1' || return ;;
		esac
		typeset _Msh_V	# local
		for _Msh_V do
			isvarname "${_Msh_V%%=*}" || die "unexport: invalid variable name: ${_Msh_V%%=*}" || return
		done
		command typeset --global --unexport "$@" || die "unexport: 'typeset' failed"
	}
elif thisshellhas KSH93FUNC && command typeset +x _Msh_test; then
	# ksh93 uses typeset without -g; this does not make the variable local,
	# as long as it's in a POSIX function defined using the name() syntax.
	unexport() {
		case $# in
		( 0 )	_Msh_dieArgs unexport "$#" 'at least 1' || return ;;
		esac
		for _Msh_nE_V do
			isvarname "${_Msh_nE_V%%=*}" || die "unexport: invalid variable name: ${_Msh_nE_V%%=*}" || return
		done
		unset -v _Msh_nE_V
		command typeset +x "$@" || die "unexport: 'typeset' failed"
	}
elif thisshellhas typeset global && command global +x _Msh_test; then
	# mksh uses a separate 'global' builtin instead of a -g flag for typeset;
	# this is equivalent to 'typeset -g' on zsh and bash 4.
	unexport() {
		case $# in
		( 0 )	_Msh_dieArgs unexport "$#" 'at least 1' || return ;;
		esac
		typeset _Msh_V	# local
		for _Msh_V do
			isvarname "${_Msh_V%%=*}" || die "unexport: invalid variable name: ${_Msh_V%%=*}" || return
		done
		command global +x "$@" || die "unexport: 'global' failed"
	}
elif thisshellhas typeset && ( typeset -g +x _Msh_test ); then	# BUG_CMDSPEXIT compat: subshell instead of 'command typeset'
	# zsh and bash 4 also have 'typeset +x', but need the -g flag to
	# keep the variable from becoming local.
	unexport() {
		case $# in
		( 0 )	_Msh_dieArgs unexport "$#" 'at least 1' || return ;;
		esac
		typeset _Msh_V	# local
		for _Msh_V do
			isvarname "${_Msh_V%%=*}" || die "unexport: invalid variable name: ${_Msh_V%%=*}" || return
		done
		for _Msh_V do
			if isset "${_Msh_V%%=*}" || ! identic "${_Msh_V%%=*}" "${_Msh_V}"; then
				command typeset -g +x "${_Msh_V}" || die "unexport: 'typeset' failed"
			else	# on zsh, 'typeset' will set the variable, so to remove export flag use 'unset' instead
				unset -v "${_Msh_V}"
			fi
		done
	}
else
	# All other shells have to use trickery: make sure 'set -a' is off,
	# then unset the variable, then assign or restore its value, then
	# restore the previous status of 'set -a'.
	unexport() {
		case $# in
		( 0 )   _Msh_dieArgs unexport "$#" 'at least 1' || return ;;
		esac
		for _Msh_nE_V do
			isvarname "${_Msh_nE_V%%=*}" || die "unexport: invalid variable name: ${_Msh_nE_V%%=*}" || return
		done
		case $- in
		( *a* ) _Msh_nE_a=y; set +a ;;
		( * )   _Msh_nE_a='' ;;
		esac
		for _Msh_nE_V do
			case ${_Msh_nE_V} in
			( *=* ) unset -v "${_Msh_nE_V%%=*}"
				eval "${_Msh_nE_V%%=*}=\${_Msh_nE_V#*=}" ;;
			( * )   if isset "${_Msh_nE_V}"; then
					eval "_Msh_nE_val=\${${_Msh_nE_V}}"
					unset -v "${_Msh_nE_V}"
					eval "${_Msh_nE_V}=\${_Msh_nE_val}"
				else
					eval "${_Msh_nE_V}="  # on {d,}ash, 'unset' will not unexport without setting first
					unset -v "${_Msh_nE_V}"
				fi ;;
			esac
		done
		case ${_Msh_nE_a} in
		( y )   set -a ;;
		esac
		unset -v _Msh_nE_V _Msh_nE_val _Msh_nE_a
	}
fi 2>/dev/null

# -------------

# Shell-quote the values of one or more variables to prepare them for
# safe use with "eval" or other parsing by the shell. If a value only
# contains shell-safe characters, it leaves it unquoted. Empty values
# are quoted.
#
# Usage: shellquote [ <options> ] <varname> ... [ [ <options> ] <varname> ... ]
#
# Options take effect for all variable names following them. Each option
# must be a separate argument.
# -f	Force quoting, even if value only contains shell-safe characters.
#	This is useful for e.g. producing string literals for glob patterns
#	or regular expressions.
# +f	Don't quote if value only contains shell-safe characters. (Default)
#
# Returns success (0) if all variables were processed successfully, and
# non-success (1) if any undefined (unset) variables were encountered. Unset
# variables are left alone. It continues even after encountering an unset
# variable.
#
# Inspired by "Rich's sh (POSIX shell) tricks":
# http://www.etalabs.net/sh_tricks.html
# under "Shell-quoting arbitrary strings":
# quote () { printf %s\\n "$1" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/'/" ; }
# Rich uses a command substitution with "sed" for this, launching two
# processes for each value to quote. The "shellquote" function does the same
# thing, but in-place. As it doesn't launch any subshells or external
# processes, it's more than 10 times faster.
if thisshellhas ADDASSIGN && case ${KSH_VERSION-} in ('@(#)MIRBSD KSH '* | '@(#)LEGACY KSH '*) ! :; esac; then
	# Additive string assignment is faster on most shells, except mksh/lksh.
	_Msh_addtoVAL='_Msh_qV_VAL+='
else
	_Msh_addtoVAL='_Msh_qV_VAL=${_Msh_qV_VAL}'
fi
if thisshellhas ARITHCMD; then
	# ((Arithmetic commands)) are the same as 'let' but faster.
	_Msh_letOpen='(('
	_Msh_letClose='))'
else
	_Msh_letOpen='let "'
	_Msh_letClose='"'
fi
eval 'shellquote() {
	_Msh_qV_ERR=4
	_Msh_qV_f=
	for _Msh_qV_N do
		case ${_Msh_qV_N} in
		( -f )	_Msh_qV_f=y; _Msh_qV_ERR=4; continue ;;
		( +f )	_Msh_qV_f=; _Msh_qV_ERR=4; continue ;;
		( "" | [0123456789]* | *[!"$ASCIIALNUM"_]* )
			_Msh_qV_ERR=2
			break ;;
		esac

		# If any of the variables to quote isn'\''t set, return status 1.
		if ! isset "${_Msh_qV_N}"; then
			_Msh_qV_ERR=1
			continue
		fi

		case ${_Msh_qV_ERR} in
		( 4 )	_Msh_qV_ERR=0 ;;
		esac

		eval "_Msh_qV_VAL=\${${_Msh_qV_N}}"

		case ${_Msh_qV_VAL} in

		# Quote empties.
		( "" )
			_Msh_qV_VAL="'\'''\''"
			;;

		# If it'\''s not safe for unescaped double-quoting, unescaped single-quoting or
		# not quoting, then use a mixture of single-quoting and backslash-escaping to
		# mitigate exponential growth with multiple levels of quoting.
		# Ref.: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02_02
		( *"'\''"* )
			case ${_Msh_qV_VAL} in
			( *[\"\$\`\\]* )
				# Split the value of the specified variable at its single quote characters (if
				# any), storing the parts into the positional parameters. Add a protector character
				# "X" at the end so a final literal single quote is counted.
				push IFS -f; IFS="'\''"; set -f
				set -- ${_Msh_qV_VAL}X
				pop IFS -f

				# First part: backslash-escape any existing initial quotes; add the initial quote.
				_Msh_qV_VAL=
				while '"${_Msh_letOpen}"'$# > 0 && ${#1} == 0'"${_Msh_letClose}"'; do
					'"${_Msh_addtoVAL}"'"\\'\''"
					shift
				done
				'"${_Msh_addtoVAL}"'"'\''${1}"
				shift

				# Second to last parts: escape existing single quotes.
				while '"${_Msh_letOpen}"'$# > 0'"${_Msh_letClose}"'; do
					# Add closing quote.
					'"${_Msh_addtoVAL}"'"'\''"
					# Backslash-escape any existing intermediary quotes.
					while '"${_Msh_letOpen}"'$# > 0 && ${#1} == 0'"${_Msh_letClose}"'; do
						'"${_Msh_addtoVAL}"'"\\'\''"
						shift
					done
					# Add the escaped single quote plus an opening quote before the next part.
					'"${_Msh_addtoVAL}"'"\\'\'''\''${1}"
					shift
				done

				# Remove the protector character. Either prevent a final pair
				# of empty single quotes, or add the final single quote.
				case ${_Msh_qV_VAL} in
				( *"'\''X" )	_Msh_qV_VAL=${_Msh_qV_VAL%"'\''X"} ;;
				( *X )		_Msh_qV_VAL="${_Msh_qV_VAL%X}'\''" ;;
				( * )		_Msh_qV_ERR=99; break ;;
				esac
				;;
			( * )
				# Safe for unescaped double quoting.
				_Msh_qV_VAL=\"${_Msh_qV_VAL}\"
				;;
			esac
			;;

		# Not safe for double quoting, but does not contain a single quote:
		# do simple single quoting without escaping anything.
		( *[\"\$\`\\]* )
			_Msh_qV_VAL="'\''${_Msh_qV_VAL}'\''"
			;;

		# If it'\''s safe to double-quote without escaping anything, do so. (A mixed quoting
		# strategy slightly mitigates exponential growth with multiple quoting levels.)
		# Ref.: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02_03
		( *[!"${SHELLSAFECHARS}"]* )
			_Msh_qV_VAL=\"${_Msh_qV_VAL}\"
			;;

		# Shell-safe chars only: only quote if -f was given.
		( * )
			case ${_Msh_qV_f:+f} in
			( f )	_Msh_qV_VAL="'\''${_Msh_qV_VAL}'\''" ;;
			esac
			;;

		esac

		# Replace the value of the specified variable with its quoted value.
		eval "${_Msh_qV_N}=\${_Msh_qV_VAL}"
	done

	case ${_Msh_qV_ERR} in
	( 0 | 1 ) ;;
	( 2 )	die "shellquote: invalid option or variable name: ${_Msh_qV_N}" ;;
	( 4 )	die "shellquote: expected variable(s) to quote" ;;
	( * )	die "shellquote: internal error (${_Msh_qV_ERR})" ;;
	esac || return
	eval "unset -v _Msh_qV_VAL _Msh_qV_f _Msh_qV_N _Msh_qV_ERR; return ${_Msh_qV_ERR}"
}'
unset -v _Msh_addtoVAL _Msh_letOpen _Msh_letClose

# Shell-quote all the positional parameters in-place.
# Usage: shellquoteparams (no arguments)
# To unquote them again, do:
#	eval "set -- $@"
# (be sure they are quoted before unquoting, or havoc will be wreaked!)
alias shellquoteparams='{ for _Msh_Q do shellquote _Msh_Q && set -- "$@" "${_Msh_Q}" && shift || die; done; unset -v _Msh_Q; }'

# Shell-quote and store (a subrange of) the current positional parameters
# into a variable. To restore them later, it is safe to do:
#	eval "set -- $varname"
# (with double quotes and non-escaped $).
# Usage: storeparams [ -f <firstparam> ] [ -t <lastparam> ] <varname>
#	 (f = from, t = to)
# NOTE: functions set by harden() call _Msh_doStoreParams() directly.
alias storeparams='_Msh_doStoreParams "$#" "$@"'
_Msh_doStoreParams() {
	_Msh_sP_f=1
	_Msh_sP_t=$1
	_Msh_sP_i=$(( $1 + 1 ))
	while	let "$# >= (_Msh_sP_i+=1)" &&
		eval "startswith \"\${${_Msh_sP_i}}\" '-' && _Msh_sP_o=\${${_Msh_sP_i}#-}"
	do
		case ${_Msh_sP_o} in
		( - )	let "_Msh_sP_i+=1"
			break ;;
		( f )	let "$# >= (_Msh_sP_i+=1)" || die "storeparams: -f: option requires an argument" || return
			eval "_Msh_sP_f=\${${_Msh_sP_i}}" ;;
		( f* )	_Msh_sP_f=${_Msh_sP_o#f} ;;
		( t )	let "$# >= (_Msh_sP_i+=1)" || die "storeparams: -t: option requires an argument" || return
			eval "_Msh_sP_t=\${${_Msh_sP_i}}" ;;
		( t* )	_Msh_sP_t=${_Msh_sP_o#t} ;;
		esac
	done
	let "$# == _Msh_sP_i" || die "storeparams: 1 non-option argument expected, got $(($# - _Msh_sP_i + 1))" || return
	eval "_Msh_sP_V=\${${_Msh_sP_i}}"
	isvarname "${_Msh_sP_V}" || die "storeparams: invalid variable name: ${_Msh_sP_V}" || return
	isint "${_Msh_sP_f}" && let "_Msh_sP_f >= 1" || die "storeparams: -f: invalid value: '${_Msh_sP_f}'" || return
	isint "${_Msh_sP_t}" || die "storeparams: -t: invalid value: '${_Msh_sP_t}'" || return
	let "_Msh_sP_t > $#" && _Msh_sP_t=$#
	_Msh_sP_PPs=''
	shift "${_Msh_sP_f}"
	_Msh_sP_i=$((_Msh_sP_f-1))
	while let "(_Msh_sP_i+=1) <= _Msh_sP_t"; do
		_Msh_sP_P=$1
		shellquote _Msh_sP_P || die "storeparams: 'shellquote' failed" || return
		_Msh_sP_PPs=${_Msh_sP_PPs:+${_Msh_sP_PPs} }${_Msh_sP_P}
		shift
	done
	eval "${_Msh_sP_V}=\${_Msh_sP_PPs}"
	unset -v _Msh_sP_f _Msh_sP_t _Msh_sP_o _Msh_sP_V _Msh_sP_i _Msh_sP_P _Msh_sP_PPs
}

# ----------------

# Internal functions to support the shell options stack

# Internal function. Convert a long-form option name to short-form option
# letter, if it exists. Leaves the result in ${_Msh_o}. Returns status 0 if a
# corresponding short-form option letter exists, otherwise returns status 1.
unset -v _Msh_optLtrCache	# for caching results that require forking a subshell
_Msh_optNamToLtr() {
	case $1 in
	# hardcode option letters guaranteed by POSIX, plus 'i'
	( interactive )	_Msh_o=i ;;
	( allexport )	_Msh_o=a ;;
	( errexit )	_Msh_o=e ;;
	( noclobber )	_Msh_o=C ;;
	( noglob )	_Msh_o=f ;;
	( noexec )	_Msh_o=n ;;
	( nounset )	_Msh_o=u ;;
	( verbose )	_Msh_o=v ;;
	( xtrace )	_Msh_o=x ;;
	( nolog )	! unset -v _Msh_o ;; # BUG_OPTNOLOG compat (the test below fails on dash)
	# shell-specific option
	( * )	case ${_Msh_optLtrCache-}: in
		( *:"$1"=?:* )
			_Msh_o=${_Msh_optLtrCache#*:"$1"=}
			_Msh_o=${_Msh_o%%:*} ;;
		( *:!"$1":* )
			unset -v _Msh_o
			return 1 ;;
		( * )	# figure out if there is a letter for that long-form option
			_Msh_o=$(
				set -o "$1" 2>/dev/null	# exits subshell with status > 0 if option does not exist
				_Msh_o1=$-
				set +o "$1" 2>/dev/null
				_Msh_o2=$-
				case $(( ${#_Msh_o1} - ${#_Msh_o2} )) in
				( 0 )	# option does not have a letter
					\exit 1 ;;
				( -* )	# the long option has an inverse effect to the letter option: swap values
					_Msh_o=${_Msh_o1}
					_Msh_o1=${_Msh_o2}
					_Msh_o2=${_Msh_o} ;;
				esac
				# for each char in ${_Msh_o1}, check if it occurs in ${_Msh_o2};
				# if it does NOT occur, we have found our letter
				while ! empty "${_Msh_o1}"; do
					_Msh_o=${_Msh_o1%${_Msh_o1#?}}	# get first letter
					if ! contains "${_Msh_o2}" "${_Msh_o}"; then
						put "${_Msh_o}"
						\exit
					fi
					_Msh_o1=${_Msh_o1#?}
				done
				\exit 1
			) || {
				unset -v _Msh_o
				_Msh_optLtrCache=${_Msh_optLtrCache-}:!$1
				return 1
			}
			_Msh_optLtrCache=${_Msh_optLtrCache-}:$1=${_Msh_o} ;;
		esac
	esac
}

# Internal function. Validate and convert a long-form option name to its
# corresponding internal stack variable.
# Usage: _Msh_optNamToVar <optname> <varname> || die ...
_Msh_optNamToVar() {
	case $1 in
	( "" | *[!"$ASCIIALNUM"_-]* )
		return 1 ;;
	esac
	if _Msh_optNamToLtr "$1"; then
		eval "$2=_Msh_ShellOpt_\${_Msh_o}"
		unset -v _Msh_o
	else
		# remove 'no' prefix if the option without it exists
		if startswith "$1" "no" && thisshellhas -o "${1#no}"; then
			set -- "${1#no}" "$2"
		fi
		# change any '-' to '_' in variable name
		eval "$2=_Msh_ShellOpt_\$1
			while contains \"\${$2}\" '-'; do
				$2=\${$2%%-*}_\${$2#*-}
			done"
	fi
}

# ----------------

# Stack functions.
# Every variable has its own stack: simply do push VAR and pop VAR.
# Also works for saving/restoring shell options, e.g.: push -f; pop -f
# Uses global variable namespace: _Msh__V*__S*
#
# Features:
#	- Saves and restores not just value, but set/unset state.
#	- Stack size is limited by memory or shell constraints only.
#	- Fast: does not launch any subshell or external process.
#	- Cleans up after itself: leaves no trace in the environment upon
#         empty stack.
#	- Matches long-form shell options to short-form shell options;
#	  for instance, "push -o noglob; pop -f" works correctly.
#	  This works even for shell-specific options.
#
# Use cases:
#	- Easily store lots of arbitary data to use later.
#	- Code blocks (not just functions) with 'fake' local variables
#	  and/or shell options. See also the var/setlocal module.
#	- Easy temporary field splitting ('push IFS' and 'pop IFS' work fine).

# --- push ---
# Push each variable's value or shell option setting on its respective stack.
# Usage: push [ --key=<value> ] <item> [ <item> ...]
#	 where <item> is a variable name, shell option (dash plus letter),
#	 or long-form shell option (two arguments, '-o' and option name).
#
# If the "--key=<value>" option is given, then for each <item>, the given
# key value is stored along with the variable's value for that position in
# the stack. Popping that value will only succeed if the same key is given
# with the 'pop' invocation. This feature helps different functions to use
# the same variable stack safely.
push() {
	# Exporting the stack would be bad; run 'push' without 'set -a' active.
	# Save the status of 'set -a' in a variable so 'push -a' works.
	# Also parse the key option, if any.
	case ${#},${1-},${-} in
	( 0,* | 1,--key=* )
		die "push: needs at least 1 non-option argument" || return ;;
	( *,"--key=${1#--key=}",*a* )
		_Msh_push_key=${1#--key=}; set +a; _Msh_push_opta=y; shift ;;
	( *,--key=*,"${-}" )
		_Msh_push_key=${1#--key=}; unset -v _Msh_push_opta; shift ;;
	( *,"$1",*a* )
		unset -v _Msh_push_key; set +a; _Msh_push_opta=y ;;
	( * )	unset -v _Msh_push_opta _Msh_push_key ;;
	esac

	# Validate variable names and shell options before doing anything. Portable shell varname
	# constraints apply. Long option names may also start with digit and contain '-'.
	_Msh_push_err=0
	unset -v _Msh_o
	for _Msh_push_V do
		case ${_Msh_o-} in		# BUG_ISSETLOOP compat: don't use ${_Msh_o+s}
		( y )	unset -v _Msh_o
			case ${_Msh_push_V} in
			( "" | *[!"$ASCIIALNUM"_-]* )
				_Msh_push_err=101
				break ;;
			esac ;;
		( * )	case ${_Msh_push_V} in
			( -o )	_Msh_o=y	# expect another argument
				continue ;;
			( -["$ASCIIALNUM"] )
				;;		# short-form shell option: ok
			( '' | [0123456789]* | *[!"$ASCIIALNUM"_]* )
				_Msh_push_err=101
				break ;;
			esac ;;
		esac
	done
	case ${_Msh_o-} in
	( y )	_Msh_push_err=100 ;;
	esac

	# Do the job.
	case ${_Msh_push_err} in
	( 0 ) for _Msh_push_V do
		# If it's a long-form shell option, convert to a short-form shell option if available
		# (so that things like 'push -o allexport; pop -a' work correctly), otherwise translate
		# the long-form shell option to an internal variable (changing any '-' to '_').
		case ${_Msh_o-} in
		( y )	if _Msh_optNamToLtr "${_Msh_push_V}"; then
				_Msh_push_V=-${_Msh_o}
			else
				if startswith "${_Msh_push_V}" "no" && thisshellhas -o "${_Msh_push_V#no}"; then
					_Msh_push_V=${_Msh_push_V#no}
				fi
				_Msh_o=${_Msh_push_V}
				_Msh_push_V="_Msh_ShellOpt_${_Msh_push_V}"
				while contains "${_Msh_push_V}" "-"; do
					_Msh_push_V=${_Msh_push_V%%-*}_${_Msh_push_V#*-}
				done
				if isset -o "${_Msh_o}"; then
					eval "${_Msh_push_V}=''"
				else
					unset -v "${_Msh_push_V}"
				fi
			fi
			unset -v _Msh_o ;;
		esac
		# If it's a (short, single) shell option, translate to internal variable.
		case ${_Msh_push_V} in
		( -o )	_Msh_o=y	# expect another argument
			continue ;;
		( -a )	case ${_Msh_push_opta+s} in
			( s )	_Msh_ShellOpt_a='' ;;
			( * )	unset -v _Msh_ShellOpt_a ;;
			esac
			_Msh_push_V='_Msh_ShellOpt_a'
			;;
		( -? )	_Msh_push_V=${_Msh_push_V#-}
			case $- in
			( *${_Msh_push_V}* )
				eval "_Msh_ShellOpt_${_Msh_push_V}=''" ;;
			( * )	unset -v "_Msh_ShellOpt_${_Msh_push_V}" ;;
			esac
			_Msh_push_V="_Msh_ShellOpt_${_Msh_push_V}"
			;;
		esac

		# Initialize/validate stack pointer.
		eval "_Msh_push_SP=\${_Msh__V${_Msh_push_V}__SP=0}"
		case ${_Msh_push_SP} in
		( '' | *[!0123456789]* ) _Msh_push_err=102; break ;;
		esac

		# Store value or unset status.
		if isset "${_Msh_push_V}"; then
			eval "_Msh__V${_Msh_push_V}__S${_Msh_push_SP}=\$${_Msh_push_V}"
		else
			unset -v "_Msh__V${_Msh_push_V}__S${_Msh_push_SP}"
		fi

		# Store key, if any.
		case ${_Msh_push_key+s} in
		( s )	eval "_Msh__V${_Msh_push_V}__K${_Msh_push_SP}=\${_Msh_push_key}" ;;
		( * )	unset -v "_Msh__V${_Msh_push_V}__K${_Msh_push_SP}" ;;
		esac

		# Increase stack pointer for next item on stack.
		: $((_Msh__V${_Msh_push_V}__SP = _Msh_push_SP + 1))
	done;; esac
	case ${_Msh_push_opta+s} in
	( s )	set -a; unset -v _Msh_push_opta ;;
	esac
	case ${_Msh_push_err} in
	( 100 )	die "push -o: long-form option name expected" ;;
	( 101 ) die "push: invalid variable name or shell option: ${_Msh_push_V}" ;;
	( 102 ) die "push: Stack pointer for ${_Msh_push_V} corrupted" ;;
	esac || return
	eval "unset -v _Msh_push_V _Msh_push_SP _Msh_push_err _Msh_push_key; return ${_Msh_push_err}"
}

# --- pop ---
# Pop each variable or shell option's last state off the stack and restore it.
#
# Usage: pop [ --keepstatus ] [ --key=<value> ] <item> [ <item> ... ]
#	 where <item> is a variable name, shell option (dash plus letter),
#	 or long-form shell option (two arguments, '-o' and option name).
#
# If the "--keepstatus" option is given, pop() will exit with the exit status
# of the command executed immediately prior to calling pop(). This can be
# helpful when restoring variables or shell options at the end of a function.
# However, note that this makes failure to pop (stack empty or key mismatch)
# a fatal error, as pop() no longer has a way to communicate this through its
# exit status.
#
# If the "--key=<value>" option is given, then for each <item>, the given key
# value is matched against the stored key value for that position in the stack.
# If there is any mismatch, no changes are made and pop returns status 2. The
# key feature helps different functions to use the same variable stack safely.
#
# Returns unsuccessfully without changing anything if *any* of the stacks
# for the specified variables or shell options is empty or has a key mismatch.
# Either all get popped, or none. This helps provide validation against stack
# inconsistency for groups of variables that should be pushed/popped together.
if thisshellhas BUG_ARITHTYPE; then
	if thisshellhas typeset && typeset -g +i _Msh_test 2>/dev/null; then
		# BUG_ARITHTYPE (older zsh) workaround: unset a possible integer
		# type restriction caused earlier by arithmetic assignment.
		_Msh_pop_BUG_ARITHTYPE_workaround='typeset -g +i "${_Msh_pop_V}"; '
	else
		_Msh_initExit 'init: pop: cannot determine BUG_ARITHTYPE workaround' \
			"This shell has BUG_ARITHTYPE but does not appear to be zsh. Modernish" \
			"was not programmed to handle this; please report his as a bug."
	fi
else
	unset -v _Msh_pop_BUG_ARITHTYPE_workaround
fi
pop() {
	_Msh_pop_oldstatus=$?	# BUG_CASESTAT compat
	case ${#},${1-},${2-} in
	( 0, | 1,--keepstatus, | 2,--keepstatus,--key=* | 2,--key=*,--keepstatus )
		die "pop: needs at least 1 non-option argument" || return ;;
	( *,--keepstatus,--key=* )
		_Msh_pop_key=${2#--key=}; shift 2 ;;
	( *,--key=*,--keepstatus )
		_Msh_pop_key=${1#--key=}; shift 2 ;;
	( *,--keepstatus,* )
		unset -v _Msh_pop_key; shift ;;
	( *,--key=*,* )
		_Msh_pop_key=${1#--key=}; unset -v _Msh_pop_oldstatus; shift ;;
	( * )	unset -v _Msh_pop_key _Msh_pop_oldstatus ;;
	esac

	# Exporting the stack would be bad; run "pop" without "set -a" active.
	# Save the status of "set -a" in a variable so "pop -a" works.
	case $- in
	( *a* )	set +a; _Msh_pop_opta=y ;;
	( * )	unset -v _Msh_pop_opta ;;
	esac

	# Validate everything before doing anything.
	_Msh_pop_err=0
	unset -v _Msh_o
	for _Msh_pop_V do
		case ${_Msh_o-} in		# BUG_ISSETLOOP compat: don'\''t use ${_Msh_o+s}
		( y )	_Msh_optNamToVar "${_Msh_pop_V}" _Msh_pop_V || { _Msh_pop_err=101; break; } ;;
		( * )	case ${_Msh_pop_V} in
			( -o )	_Msh_o=y	# expect another argument
				continue ;;
			( -["$ASCIIALNUM"] )
				_Msh_pop_V="_Msh_ShellOpt_${_Msh_pop_V#-}" ;;
			( "" | [0123456789]* | *[!"$ASCIIALNUM"_]* )
				_Msh_pop_err=101
				break ;;
			esac ;;
		esac

		# Check for stack empty
		eval "_Msh_pop_SP=\${_Msh__V${_Msh_pop_V}__SP+s},\${_Msh__V${_Msh_pop_V}__SP-}"
		case ${_Msh_pop_SP} in
		( , )	_Msh_pop_err=$((_Msh_pop_err<1 ? 1 : _Msh_pop_err)); continue ;;
		( s, | s,0* | s,*[!0123456789]* )
			_Msh_pop_err=102; continue ;;
		esac

		# Match stored key against given key
		_Msh_pop_SP=$((_Msh__V${_Msh_pop_V}__SP - 1))
		eval "case \${_Msh_pop_key+k},\${_Msh_pop_key-},\${_Msh__V${_Msh_pop_V}__K${_Msh_pop_SP}+s} in
		( ,, | k,\"\${_Msh__V${_Msh_pop_V}__K${_Msh_pop_SP}-}\",s )
			;;
		( * )	_Msh_pop_err=\$((_Msh_pop_err<2 ? 2 : _Msh_pop_err)) ;;
		esac"
	done
	case ${_Msh_o-} in
	( y )	_Msh_pop_err=100 ;;	# -o without long option name
	esac

	# Do the job.
	case ${_Msh_pop_err} in
	( 0 ) for _Msh_pop_V do
		# Convert long-form shell option to short form if available, then to variable
		case ${_Msh_o-} in
		( y )	if startswith "${_Msh_pop_V}" "no" && thisshellhas -o "${_Msh_pop_V#no}"; then
				_Msh_pop_V=${_Msh_pop_V#no}
			fi
			_Msh_pop_o=${_Msh_pop_V}
			_Msh_optNamToVar "${_Msh_pop_V}" _Msh_pop_V || { _Msh_pop_err=103; break; } ;;
		esac

		# If shell option, translate to internal variable.
		case ${_Msh_pop_V} in
		( -o )	_Msh_o=y	# expect another argument
			continue ;;
		( -? )	_Msh_pop_V="_Msh_ShellOpt_${_Msh_pop_V#-}" ;;
		esac

		# Decrease stack pointer so it points to the item to pop.
		: $(( _Msh_pop_SP = ( _Msh__V${_Msh_pop_V}__SP -= 1 ) ))

		# Restore value or unset status.
		if isset "_Msh__V${_Msh_pop_V}__S${_Msh_pop_SP}"; then
			eval "${_Msh_pop_BUG_ARITHTYPE_workaround-}${_Msh_pop_V}=\${_Msh__V${_Msh_pop_V}__S${_Msh_pop_SP}}"
		else
			unset -v "${_Msh_pop_V}"
		fi

		# Clean up: unset the stack variable we just popped off the stack, and its key (if any).
		unset -v "_Msh__V${_Msh_pop_V}__S${_Msh_pop_SP}" "_Msh__V${_Msh_pop_V}__K${_Msh_pop_SP}"

		# Clean up: if the stack is empty, unset the stack pointer.
		case ${_Msh_pop_SP} in
		( 0 )	unset -v "_Msh__V${_Msh_pop_V}__SP" _Msh_pop_SP ;;
		esac

		# If it'\''s a shell option variable, restore the shell option.
		case ${_Msh_pop_V} in
		( _Msh_ShellOpt_a )
			case ${_Msh_ShellOpt_a+s} in
			( s )	_Msh_pop_opta=y
				unset -v _Msh_ShellOpt_a ;;
			( * )	unset -v _Msh_pop_opta ;;
			esac
			;;
		( _Msh_ShellOpt_[bcdefghijklmnpqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ] )
			if isset "${_Msh_pop_V}"; then
				set "-${_Msh_pop_V#_Msh_ShellOpt_}"
				unset -v "${_Msh_pop_V}"
			else
				case $- in
				( *${_Msh_pop_V#_Msh_ShellOpt_}* )
					set "+${_Msh_pop_V#_Msh_ShellOpt_}"
					;;
				esac
			fi
			;;
		( _Msh_ShellOpt_?* )
			if isset "${_Msh_pop_V}"; then
				set -o "${_Msh_pop_o}"
				unset -v "${_Msh_pop_V}"
			elif isset -o "${_Msh_pop_o}"; then
				set +o "${_Msh_pop_o}"
			fi
			unset -v _Msh_pop_o ;;
		esac
	done;; esac
	case ${_Msh_pop_opta+s} in
	( s )	set -a; unset -v _Msh_pop_opta ;;
	esac
	case ${_Msh_pop_err} in
	( 100 )	die "pop -o: long-form option name expected" ;;
	( 101 ) die "pop: invalid variable name or shell option: ${_Msh_pop_V}" ;;
	( 102 ) die "pop: Stack pointer for ${_Msh_pop_V} corrupted" ;;
	( 103 ) die "pop: internal error" ;;
	esac || return
	case ${_Msh_pop_oldstatus+s} in
	( s )	eval "unset -v _Msh_pop_V _Msh_pop_SP _Msh_pop_err _Msh_pop_oldstatus _Msh_pop_key
		case ${_Msh_pop_err} in
		( 0 )	;;
		( * )	die \"pop --keepstatus: fatal: couldn'\''t pop \$@${_Msh_pop_SP+${_Msh_pop_key+ (key mismatch)}}\"
			return ;;
		esac
		return ${_Msh_pop_oldstatus}" ;;
	( * )	eval "unset -v _Msh_pop_V _Msh_pop_SP _Msh_pop_err _Msh_pop_key; return ${_Msh_pop_err}" ;;
	esac
}

# stackempty: Check if there is anything left to pop on a stack. Returns 0
# (true) if the stack is empty or there is a key mismatch, 1 (false) if not.
# Usage:  stackempty [ --force ] [ --key=<value> ] <item>
# '--force' ignores keys altogether.
# The <item> can be either '@' to check the positional parameters stack,
# '--trap=' plus a signal name to check a signal's trap stack, '-' plus
# a shell option letter to check a short-form shell option's stack, '-o'
# plus a separate argument to check a long-form shell option's stack, or
# a variable name to check a variable's stack.
stackempty() {
	unset -v _Msh_stkE_K _Msh_stkE_f
	while :; do
		case ${1-} in
		( -- )	shift; break ;;
		( --key=* )
			_Msh_stkE_K=${1#--key=} ;;
		( --force )
			_Msh_stkE_f=y ;;
		( -["$ASCIIALNUM"] | --trap=* )
			break ;;
		( -* )	die "stackempty: invalid option: $1" || return ;;
		( * )	break ;;
		esac
		shift
	done
	case ${#},${1-} in
	( 1,@ )	_Msh_stkE_V='_Msh_PPs' ;;
	( 1,--trap=* )
		_Msh_arg2sig "${1#--trap=}" || die "stackempty: invalid signal specification: ${_Msh_sig}" || return
		_Msh_stkE_V=_Msh_trap${_Msh_sigv}
		unset -v _Msh_sig _Msh_sigv ;;
	( 1,-o )
		die "stackempty: -o: one long-form option expected" || return ;;
	( 1,-["$ASCIIALNUM"] )
		_Msh_stkE_V=_Msh_ShellOpt_${1#-} ;;
	( 1, | 1,[0123456789]* | 1,*[!"$ASCIIALNUM"_]* )
		die "stackempty: invalid variable name or shell option: $1" || return ;;
	( 1,* )	_Msh_stkE_V=$1 ;;
	( 2,-o )
		_Msh_optNamToVar "$2" _Msh_stkE_V || die "stackempty: invalid long option name: $2" || return ;;
	( * )	die "stackempty: needs exactly 1 non-option argument" || return ;;
	esac
	case ${_Msh_stkE_f+f} in
	( f )	! isset "_Msh__V${_Msh_stkE_V}__SP" ;;
	( "" )	! isset "_Msh__V${_Msh_stkE_V}__SP" \
		|| ! eval "identic \"\${_Msh_stkE_K+s},\${_Msh_stkE_K-}\" \
\"\${_Msh__V${_Msh_stkE_V}__K$((_Msh__V${_Msh_stkE_V}__SP-1))+s},\${_Msh__V${_Msh_stkE_V}__K$((_Msh__V${_Msh_stkE_V}__SP-1))-}\"" ;;
	esac
	eval "unset -v _Msh_stkE_V _Msh_stkE_K _Msh_stkE_f; return $?"
}

# stacksize: Leave the size of an item's stack in $REPLY and optionally
# write it to standard output. Usage:
#	stacksize [ --silent | --quiet ] [ @ | --trap=<sig> | -<opt> | -o optname | <varname> ]
# --silent, --quiet: suppresses writing to standard output.
stacksize() {
	unset -v _Msh_stacksize_s
	while :; do
		case ${1-} in
		( -- )	shift; break ;;
		( --silent | --quiet )
			_Msh_stacksize_s='' ;;
		( -["$ASCIIALNUM"] | --trap=* )
			break ;;
		( -* )	die "stacksize: invalid option: $1" || return ;;
		( * )	break ;;
		esac
		shift
	done
	case ${#},${1-} in
	( 1,@ )	REPLY=${_Msh__V_Msh_PPs__SP:-0} ;;
	( 1,--trap=* )
		_Msh_arg2sig "${1#--trap=}" || die "stacksize: invalid signal specification: ${_Msh_sig}" || return
		eval "REPLY=\${_Msh__V_Msh_trap${_Msh_sigv}__SP:-0}"
		unset -v _Msh_sig _Msh_sigv ;;
	( 1,-o )
		die "stacksize: -o: long-form option name expected" || return ;;
	( 2,-o )
		_Msh_optNamToVar "$2" _Msh_stacksize_V || die "stacksize: -o: invalid long-form option: $2" || return
		eval "REPLY=\${_Msh__V${_Msh_stacksize_V}__SP:-0}"
		unset -v _Msh_stacksize_V ;;
	( 1,-["$ASCIIALNUM"] )
		eval "REPLY=\${_Msh__V_Msh_ShellOpt_${1#-}__SP:-0}" ;;
	( 1,'' | 1,[0123456789]* | 1,*[!"$ASCIIALNUM"_]* )
		die "stacksize: invalid variable name or shell option: $1" || return ;;
	( 1,* )	eval "REPLY=\${_Msh__V${1}__SP:-0}" ;;
	( * )	_Msh_dieArgs stacksize "$#" "1 non-option argument" || return ;;
	esac
	if isset _Msh_stacksize_s; then
		unset -v _Msh_stacksize_s
	else
		putln "$REPLY"
	fi
}


# Outputs the contents of a variable or shell options's stack, top down, one
# item per line.
# Usage: printstack [ --quote ] <item>
# The <item> can be a variable name, '@', or --trap=<signal>.
# Option --quote shell-quotes each stack value before printing it. This allows
# parsing of multi-line or otherwise complicated values.
# Column 1 to 7 of the output contain the number of the item (down to 0).
# If the item is set, column 8 and 9 contain a colon and a space, and
# if the value is non-empty or quoted, column 10 and up contain the value.
# Sets of values that were pushed with a key are started with the special
# string '--- key: <value>'. A subsequent set pushed with no key is
# started with the string '--- (key off)'.
printstack() {
	_Msh_pSo_Q=''
	while :; do
		case ${1-} in
		( -- )	shift; break ;;
		( --quote )
			_Msh_pSo_Q=yes ;;
		( -["$ASCIIALNUM"] | --trap=* )
			break ;;
		( -* )	die "stackempty: invalid option: $1" || return ;;
		( * )	break ;;
		esac
		shift
	done

	case ${#},$1 in
	( 1,@ )	set -- _Msh_PPs ;;			# positional parameters
	( 1,--trap=* )
		_Msh_arg2sig "${1#--trap=}" || die "printstack: invalid signal specification: ${_Msh_sig}" || return
		set -- "_Msh_trap${_Msh_sigv}"
		unset -v _Msh_sig _Msh_sigv ;;
	( 1,-o )
		die "printstack: -o: one long-form option expected" || return ;;
	( 1,-["$ASCIIALNUM"] )
		set -- "_Msh_ShellOpt_${1#-}" ;;
	( 1, | 1,[0123456789]* | 1,*[!"$ASCIIALNUM"_]* )
		die "printstack: invalid variable name: $1" || return ;;
	( 1,* )	;;
	( 2,-o )
		_Msh_optNamToVar "$2" _Msh_pS_V || die "printstack: invalid long option name: $2" || return
		set -- "${_Msh_pS_V}"
		unset -v _Msh_pS_V ;;
	( * )	_Msh_dieArgs printstack "$#" '1 non-option argument' || return ;;
	esac

	# Return non-success if stack empty.
	if ! isset "_Msh__V${1}__SP"; then
		unset -v _Msh_pSo_Q
		return 1
	fi

	# Validate stack pointer.
	eval "_Msh_pS_i=\${_Msh__V${1}__SP}"
	case ${_Msh_pS_i} in
	( '' | *[!0123456789]* ) die "printstack: Stack pointer for $1 corrupted" || return ;;
	esac

	# Output the stack.
	unset -v _Msh_pS_key
	while let '(_Msh_pS_i-=1) >= 0'; do
		# print key, if changed from prev item
		if isset "_Msh__V${1}__K${_Msh_pS_i}"; then
			if ! eval "identic \"\${_Msh_pS_key-}\" \"\${_Msh__V${1}__K${_Msh_pS_i}}\""; then
				eval "_Msh_pS_key=\${_Msh__V${1}__K${_Msh_pS_i}}"
				_Msh_pS_VAL=${_Msh_pS_key}
				case ${_Msh_pSo_Q:+n} in
				( n )	shellquote -f _Msh_pS_VAL ;;
				esac
				putln "--- key: ${_Msh_pS_VAL}"
			fi
		elif isset _Msh_pS_key; then
			unset -v _Msh_pS_key
			putln "--- (key off)"
		fi
		# print item
		if isset "_Msh__V${1}__S${_Msh_pS_i}"; then
			eval "_Msh_pS_VAL=\${_Msh__V${1}__S${_Msh_pS_i}}"
			case ${_Msh_pSo_Q:+n} in
			( n )	shellquote -f _Msh_pS_VAL ;;
			esac
			PATH=$DEFPATH command printf '%7d: %s\n' "${_Msh_pS_i}" "${_Msh_pS_VAL}"
		else
			PATH=$DEFPATH command printf '%7d\n' "${_Msh_pS_i}"
		fi || die "printstack: 'printf' failed"
	done

	unset -v _Msh_pS_i _Msh_pSo_Q _Msh_pS_VAL _Msh_pS_key
}

# Empties one or more variables' or shell options' stacks.
# Usage: clearstack [ --key=<value> ] [ --force ] <item> [ <item> ... ]
#
# If (part of) the stack is keyed or a --key is given, only clears until a key
# mismatch is encountered. '--force' overrides this and always clears the
# entire stack (be careful, e.g. don't use within setlocal ... endlocal).
#
# Empties *nothing* if one of the specified items' stack is already
# empty or has nothing to clear due to a key mismatch.
# This allows for extra validation when treating several items as a group.
#
# Return status: 0 on success, 1 if stack was already empty, 2 if
# there was nothing to clear due to a key mismatch.
clearstack() {
	unset -v _Msh_cS_key _Msh_cS_f
	while :; do
		case ${1-} in
		( -- )	shift; break ;;
		( --key=* )
			_Msh_cS_key=${1#--key=} ;;
		( --force )
			_Msh_cS_f=y ;;
		( --trap=* | -o )
			break ;;
		( -* )	die "clearstack: invalid option: $1" || return ;;
		( * )	break ;;
		esac
		shift
	done
	case $#,${_Msh_cS_key+k},${_Msh_cS_f+f} in
	(0,*)	die "clearstack: needs at least 1 non-option argument" || return ;;
	(*,kf)	die "clearstack: options --key= and --force are mutually exclusive" || return ;;
	esac

	# Validate everything before doing anything
	_Msh_cS_err=0
	unset -v _Msh_o
	for _Msh_cS_V do
		case ${_Msh_o-} in		# BUG_ISSETLOOP compat: don't use ${_Msh_o+s}
		( y )	_Msh_optNamToVar "${_Msh_cS_V}" _Msh_cS_V \
			|| die "clearstack: invalid long option name: ${_Msh_cS_V}" || return ;;
		( * )	case ${_Msh_cS_V} in
			( @ )	_Msh_cS_V=_Msh_PPs ;;
			( --trap=* )
				_Msh_arg2sig "${_Msh_cS_V#--trap=}" \
				|| die "clearstack --trap: invalid signal specification: ${_Msh_sig}" || return
				_Msh_cS_V=_Msh_trap${_Msh_sigv} ;;
			( -o )	_Msh_o=y	# expect another argument
				continue ;;
			( -["$ASCIIALNUM"] )
				_Msh_cS_V="_Msh_ShellOpt_${_Msh_cS_V#-}" ;;
			( '' | [0123456789]* | *[!"$ASCIIALNUM"_]* )
				die "clearstack: invalid variable name or shell option: $_Msh_cS_V" || return ;;
			esac ;;
		esac

		# Check for stack empty
		eval "_Msh_cS_SP=\${_Msh__V${_Msh_cS_V}__SP+s},\${_Msh__V${_Msh_cS_V}__SP-}"
		case ${_Msh_cS_SP} in
		( , )	_Msh_cS_err=$((_Msh_cS_err<1 ? 1 : _Msh_cS_err)); continue ;;  # stack empty
		( s, | s,0* | s,*[!0123456789]* )
			die "clearstack: Stack pointer for ${_Msh_cS_V} corrupted" || { _Msh_cS_err=$?; break; } ;;
		esac

		# Match stored key against given key, unless --force was given
		case ${_Msh_cS_f+s} in
		( "" )	_Msh_cS_SP=$((_Msh__V${_Msh_cS_V}__SP - 1))
			eval "case \${_Msh_cS_key+k},\${_Msh_cS_key-},\${_Msh__V${_Msh_cS_V}__K${_Msh_cS_SP}+s} in
			( ,, | k,\"\${_Msh__V${_Msh_cS_V}__K${_Msh_cS_SP}-}\",s )
				;;
			( * )	_Msh_cS_err=2 ;;
			esac" ;;
		esac
	done

	# Do the job
	case ${_Msh_cS_err} in
	( 0 ) for _Msh_cS_V do
		case ${_Msh_o-} in
		( y )	_Msh_optNamToVar "${_Msh_cS_V}" _Msh_cS_V || die "clearstack: internal error" || return ;;
		esac
		case ${_Msh_cS_V} in
		( @ )	_Msh_cS_V=_Msh_PPs ;;
		( --trap=* )
			_Msh_arg2sig "${_Msh_cS_V#--trap=}"
			push _Msh_cS_key _Msh_cS_f
			clearstack ${_Msh_cS_f+"--force"} ${_Msh_cS_key+"--key=$_Msh_cS_key"} \
				"_Msh_trap${_Msh_sigv}_opt" "_Msh_trap${_Msh_sigv}_ifs"
			pop _Msh_cS_key _Msh_cS_f
			_Msh_cS_V=_Msh_trap${_Msh_sigv}
			if stackempty --force "_Msh_trap${_Msh_sigv}_opt" && ! isset "_Msh_POSIXtrap${_Msh_sigv}"; then
				case ${_Msh_sig} in
				(EXIT)	command trap - 0 ;;	# BUG_TRAPEXIT COMPAT
				(DIE)	;;
				( * )	command trap - "${_Msh_sig}" ;;
				esac || die "clearstack: internal error" || return
			fi
			unset -v _Msh_sig _Msh_sigv ;;
		( -o )	_Msh_o=y	# expect another argument
			continue ;;
		( -? )	_Msh_cS_V="_Msh_ShellOpt_${_Msh_cS_V#-}" ;;
		esac
		eval "_Msh_cS_SP=\${_Msh__V${_Msh_cS_V}__SP}"
		while let "(_Msh_cS_SP-=1) >= 0" &&
			# Clear until the key doesn't match, unless --force was given
			case ${_Msh_cS_f+s} in
			( "" )	eval "case \${_Msh_cS_key+k},\${_Msh_cS_key-},\${_Msh__V${_Msh_cS_V}__K${_Msh_cS_SP}+s} in
				( ,, | k,\"\${_Msh__V${_Msh_cS_V}__K${_Msh_cS_SP}-}\",s )
					;;
				( * )	! : ;;
				esac" ;;
			esac
		do
			unset -v "_Msh__V${_Msh_cS_V}__S${_Msh_cS_SP}" "_Msh__V${_Msh_cS_V}__K${_Msh_cS_SP}"
		done
		if let "_Msh_cS_SP >= 0"; then
			let "_Msh__V${_Msh_cS_V}__SP = _Msh_cS_SP + 1"
		else
			unset -v "_Msh__V${_Msh_cS_V}__SP"
		fi
	done;; esac
	eval "unset -v _Msh_cS_V _Msh_cS_SP _Msh_cS_key _Msh_cS_f _Msh_cS_err; return ${_Msh_cS_err}"
}

# -----------------------------------
# --- Positional parameters stack ---
# Note: stackempty(), stacksize(), printstack() and clearstack() above
# support the positional parameters stack with a special '@' argument.

# Save the current positional parameters on the stack.
alias pushparams='{ unset -v _Msh_PPs; '\
'for _Msh_Q do shellquote _Msh_Q || die; _Msh_PPs=${_Msh_PPs+${_Msh_PPs} }${_Msh_Q}; done; '\
'push _Msh_PPs; unset -v _Msh_PPs _Msh_Q; }'

# Restore the last-pushed positional parameters. Returns successfully if
# there were positional parameters to restore, unsuccessfully if not.
alias popparams='{ pop _Msh_PPs && eval "set -- ${_Msh_PPs-}" && unset -v _Msh_PPs; }'

# -----------------
# ---Trap stack ---

# Convert an argument in either ${_Msh_sig} or the first argument to a signal name minus the SIG
# prefix, check it for validity, sanitise it, and leave the result in ${_Msh_sig}. The
# corresponding variable name component is left in ${_Msh_sigv}.
# Returns unsuccessfully if the argument does not correspond to a valid signal.
# Internal function; not for use by programs. Subject to change without notice.
_Msh_sigCache=
_Msh_psigCache=
_Msh_arg2sig() {
	unset -v _Msh_sigv
	case ${1:+n} in
	( n )	_Msh_sig=$1 ;;
	esac
	case ${_Msh_sig} in
	( 0 )	_Msh_sig=EXIT; _Msh_sigv=EXIT ;;
	( *[!0123456789]* )
		# Signal name: sanitise and validate
		_Msh_arg2sig_sanitise || return 1
		case ${_Msh_sig} in
		( DIE | EXIT )
			_Msh_sigv=${_Msh_sig}
			return ;;
		( ERR )	if thisshellhas TRAPZERR; then
				_Msh_sigv=ZERR
				return
			fi ;;
		esac
		# Check the 'kill -l' cache to see if it's known
		case ${_Msh_sigCache:+n} in
		( '' )	_Msh_tmp_arg2sig_initCache || die "_Msh_arg2sig: internal error" || return
			unset -f _Msh_tmp_arg2sig_initCache ;;
		esac
		case ${_Msh_sigCache} in
		( *\|${_Msh_sig}${CCn}* )
			# use signal number as varname component
			_Msh_sigv=${_Msh_sigCache%\|${_Msh_sig}${CCn}*}
			_Msh_sigv=${_Msh_sigv##*${CCn}} ;;
		( * )	# check for shell-specific numberless pseudosignal
			case ${_Msh_sig} in
			( *[!${ASCIIALNUM}_]* )
				return 1 ;;  # must be valid varname component
			esac
			# testing for a pseudosig requires forking a subshell, so cache results
			case "|${_Msh_psigCache}|" in
			( *"|${_Msh_sig}|"* )
				_Msh_sigv=${_Msh_sig} ;;
			( *"|!${_Msh_sig}|"* )
				return 1 ;;
			( * )	if (command trap - "${_Msh_sig}") 2>/dev/null; then
					_Msh_sigv=${_Msh_sig}
					_Msh_psigCache=${_Msh_psigCache}${_Msh_psigCache:+\|}${_Msh_sig}
				else
					_Msh_psigCache=${_Msh_psigCache}${_Msh_psigCache:+\|}!${_Msh_sig}
					return 1
				fi ;;
			esac ;;
		esac ;;
	( * )	# Signal number: retrieve a 'kill -l' name from the cache
		case ${_Msh_sigCache:+n} in
		( '' )	_Msh_tmp_arg2sig_initCache || die "_Msh_arg2sig: internal error" || return
			unset -f _Msh_tmp_arg2sig_initCache ;;
		esac
		case ${_Msh_sigCache} in
		( *${CCn}$((_Msh_sig % 128))\|[!${CCn}]* )
			_Msh_sigv=$((_Msh_sig % 128))
			_Msh_sig=${_Msh_sigCache#*${CCn}${_Msh_sigv}\|}
			_Msh_sig=${_Msh_sig%%${CCn}*} ;;
		( * )	return 1 ;;
		esac ;;
	esac
}
# Sanitise/canonicalise the signal name in _Msh_sig. Return unsuccessfully if it's not syntactically valid.
_Msh_arg2sig_sanitise() {
	case ${_Msh_sig} in
	( '' | *[!"$SHELLSAFECHARS"]* )
		return 1 ;;
	( [Ss][Ii][Gg][Nn][Aa][Ll][123456789]* )
		# DragonflyBSD's SignalNN names are unusable, though the signals exist; change back to number
		_Msh_sig=${_Msh_sig#[Ss][Ii][Gg][Nn][Aa][Ll]} ;;
	( *[abcdefghijklmnopqrstuvwxyz]* )
		toupper _Msh_sig ;;
	( *[!0123456789]* )
		;;
	( * )	# It's a signal number, not a name
		return 1 ;;
	esac
	_Msh_sig=${_Msh_sig#SIG}
}
# Temp function to initialise the 'kill -l' cache on first use of _Msh_arg2sig().
_Msh_tmp_arg2sig_initCache() {
	_Msh_sigCache=
	push IFS -f _Msh_sig _Msh_num
	IFS=\|; set -f  # split the cmd. subst. below on '|' without globbing
	for _Msh_sig in $(
		_Msh_i=0 PATH=$DEFPATH
		while let "(_Msh_i+=1)<128"; do
			command kill -l "${_Msh_i}" && put "${_Msh_i}|"
		done 2>/dev/null)
	do
		_Msh_num=${_Msh_sig##*$CCn}
		_Msh_sig=${_Msh_sig%$CCn*}
		_Msh_arg2sig_sanitise || continue  # Sanitise even 'kill -l' output; it's not always reliable
		_Msh_sigCache=${_Msh_sigCache:-${CCn}}${_Msh_num}\|${_Msh_sig}${CCn}
	done
	pop IFS -f _Msh_sig _Msh_num
	readonly _Msh_sigCache
}

# Adds a command to each specified signal's trap stack, activating the
# corresponding system trap if it wasn't already active.
# Along with the command, current $IFS and $- are pushed, so they
# can be restored when that trap is executed in a subshell.
# Usage: pushtrap [ --key=<value> ] [ -- ] <command> <sigspec> [ <sigspec> ... ]
pushtrap() {
	unset -v _Msh_pushtrap_key
	while :; do
		case ${1-} in
		( -- )	shift; break ;;
		( --key=* )
			_Msh_pushtrap_key=${1#--key=} ;;
		( -* )	die "pushtrap: invalid option: $1" || return ;;
		( * )	break ;;
		esac
		shift
	done
	case $# in
	( 0|1 )	die "pushtrap: needs at least 2 non-option arguments" || return ;;
	esac
	_Msh_pushtrapCMD=$1
	shift
	_Msh_sigs=''
	for _Msh_sig do
		_Msh_arg2sig || die "pushtrap: invalid signal specification: ${_Msh_sig}" || return
		_Msh_sigs=${_Msh_sigs}\ ${_Msh_sig}:${_Msh_sigv}
	done
	eval "set --${_Msh_sigs}"
	# Don't set the system trap when in a subshell; this would prematurely execute emulated POSIX traps.
	# I.e.: in subshells, pushtrap() does nothing useful except push inactive traps for printing later.
	insubshell && _Msh_setSysTrap=':' || _Msh_setSysTrap='trap'
	for _Msh_sig do
		_Msh_sigv=${_Msh_sig##*:}
		_Msh_sig=${_Msh_sig%:*}
		eval "_Msh_trap${_Msh_sigv}=\${_Msh_pushtrapCMD} _Msh_trap${_Msh_sigv}_opt=\$-"
		isset IFS && eval "_Msh_trap${_Msh_sigv}_ifs=\$IFS" || unset -v "_Msh_trap${_Msh_sigv}_ifs"
		push ${_Msh_pushtrap_key+"--key=$_Msh_pushtrap_key"} \
			"_Msh_trap${_Msh_sigv}" "_Msh_trap${_Msh_sigv}_opt" "_Msh_trap${_Msh_sigv}_ifs"
		case ${_Msh_sig} in
		(DIE)	;;
		(EXIT)	command "${_Msh_setSysTrap}" "_Msh_doTraps ${_Msh_sig} ${_Msh_sigv}" 0 ;;  # BUG_TRAPEXIT compat
		( * )	command "${_Msh_setSysTrap}" "_Msh_doTraps ${_Msh_sig} ${_Msh_sigv}" "${_Msh_sig}" ;;
		esac || die "pushtrap: 'trap' failed" || return
		unset -v "_Msh_trap${_Msh_sigv}" "_Msh_trap${_Msh_sigv}_ifs" "_Msh_trap${_Msh_sigv}_opt"
	done
	unset -v _Msh_pushtrapCMD _Msh_pushtrap_key _Msh_sig _Msh_sigv _Msh_sigs _Msh_setSysTrap
}

# Removes a trap from each signal's trap stack without executing it.
# Clear the signal's master trap if there are no more left on the stack.
# Usage: poptrap [ --key=<value> ] [ -- ] <sigspec> [ <sigspec> ... ]
# Removes *nothing* if one of the specified signals' stack is already empty,
# or if one of the values' stored keys doesn't match the specified key;
# this allows for extra validation when treating several items as a group.
# The REPLY variable will be filled with eval-ready (properly shell-quoted)
# commands to re-push each popped trap, each in the form of:
#	pushtrap -- "<command>" SIGNALNAME
# Multiple commands are separated by newline characters.
poptrap() {
	unset -v _Msh_poptrap_key
	while :; do
		case ${1-} in
		( -- )	shift; break ;;
		( --key=* )
			_Msh_poptrap_key=${1#--key=} ;;
		( -* )	die "poptrap: invalid option: $1" || return ;;
		( * )	break ;;
		esac
		shift
	done
	case $# in
	( 0 )	die "poptrap: needs at least 1 non-option argument" || return ;;
	esac
	_Msh_sigs=''
	for _Msh_sig do
		_Msh_arg2sig || die "poptrap: invalid signal specification: ${_Msh_sig}" || return
		if stackempty ${_Msh_poptrap_key+"--key=$_Msh_poptrap_key"} "_Msh_trap${_Msh_sigv}"; then
			unset -v _Msh_sig _Msh_sigv _Msh_sigs
			return 1
		fi
		_Msh_sigs=${_Msh_sigs}\ ${_Msh_sig}:${_Msh_sigv}
	done
	eval "set --${_Msh_sigs}"
	unset -v REPLY
	for _Msh_sig do
		_Msh_sigv=${_Msh_sig##*:}
		_Msh_sig=${_Msh_sig%:*}
		# (note: this assumes pop() and shellquote() don't change $REPLY)
		pop ${_Msh_poptrap_key+"--key=$_Msh_poptrap_key"} \
			"_Msh_trap${_Msh_sigv}" "_Msh_trap${_Msh_sigv}_opt" "_Msh_trap${_Msh_sigv}_ifs" \
			|| die "poptrap: stack corrupted: ${_Msh_sig}" || return
		shellquote -f "_Msh_trap${_Msh_sigv}"
		eval "REPLY=\"\${REPLY+\$REPLY\$CCn}pushtrap -- \${_Msh_trap${_Msh_sigv}} ${_Msh_sig}\""
		unset -v "_Msh_trap${_Msh_sigv}" "_Msh_trap${_Msh_sigv}_opt" "_Msh_trap${_Msh_sigv}_ifs"
		if stackempty --force "_Msh_trap${_Msh_sigv}" \
		&& ! isset "_Msh_POSIXtrap${_Msh_sigv}" \
		&& ! identic "${_Msh_sig}" DIE; then
			identic "${_Msh_sig}" EXIT && _Msh_sig=0  # BUG_TRAPEXIT compat
			command trap - "${_Msh_sig}"
		fi
	done
	unset -v _Msh_sig _Msh_sigv _Msh_sigs
}

# Do the traps for a signal. Start from the top of the stack, but don't pop
# the commands, as they may be trapped repeatedly. Also handle the traps for
# the POSIX 'trap' command defined below.
_Msh_doTraps() {
	# Save current exit status in $3.
	set -- "$1" "$2" "$?"
	# Execute the commands on the trap stack, last to first, if any.
	# Deactivate the trap stack if we're in a subshell; bad things happen if a subshell inherits
	# pushed traps from the main shell, e.g. modules cleaning up after themselves prematurely.
	if ! stackempty --force "_Msh_trap${2}" && ! insubshell; then
		_Msh_doTraps_i=$((_Msh__V_Msh_trap${2}__SP))
		while let '(_Msh_doTraps_i-=1) >= 0'; do
			# Execute each stack trap in a subshell, so 'exit' cannot stop the trap stack and
			# traps from different modules can't interfere with each other (or the main shell).
			(_Msh_doOneStackTrap "${2}" "${_Msh_doTraps_i}" "${3}")
		done
		unset -v _Msh_doTraps_i
	fi
	# If there is a trap set by the POSIX 'trap' command, excecute it
	# last, in case it contains an 'exit' command. This means POSIX traps
	# should not use any functionality from modernish modules that push
	# their own traps to clean up after themselves.
	if isset "_Msh_POSIXtrap${2}"; then
		_Msh_doPosixTrap "${2}" "${3}"
	fi
	# On interactive shells, SIGINT is used for cleanup after die(), so clear
	# out the SIGINT stack traps to make sure they are executed only once.
	if isset -i && identic "$1" INT; then
		clearstack --force --trap=INT
		unset -v "_Msh_POSIXtrap${2}"
		if match "${BASH_VERSION-}" '[1234].*'; then
			# bash < 5.0 has a bug that would kill an interactive shell upon resending SIGINT as we
			# do below. This workaround makes die() ineffective on an interactive bash if called
			# from a shell function that was called from a shell function while an INT trap is set.
			command trap - INT
			return 130
		fi
	fi
	# If there is no emulated POSIX trap, and the signal is not CONT or a pseudosignal, and we're
	# not in a subshell, the signal was ignored contrary to expectations. So unignore and resend it.
	if ! isset "_Msh_POSIXtrap${2}" && case $1 in (CONT|EXIT) ! : ;; esac && ! insubshell; then
		# bash and ksh will trigger the EXIT trap on sending any untrapped signal, which is
		# inconsistent with other shells. Remedy this for stack traps in scripts only.
		if ! isset -i; then
			command trap - 0  # BUG_TRAPEXIT compat
		fi
		# Unignore (by unsetting the trap) and resend the signal, possibly killing the shell.
		command trap - "$1"
		case $1 in
		( *[!0123456789]* )
			command kill -s "$1" "$$" 2>/dev/null ;;	# signal name
		( * )	command kill "-$1" "$$" 2>/dev/null ;;		# signal with no name (number only)
		esac || {
			# If 'kill' failed, it must have been a pseudosignal. Restore.
			command trap "_Msh_doTraps $1 $2" "$1" &&
			if ! isset -i && { isset _Msh_POSIXtrapEXIT || isset _Msh__V_Msh_trapEXIT__SP; }; then
				command trap '_Msh_doTraps EXIT EXIT' 0	# BUG_TRAPEXIT compat
			fi
		} || die "trap stack: restore pseudosig trap: internal error"
		# (Note: some shells (zsh, older bash) will keep running until the end of
		# the trap routine and then act on the suicide. But since the 'kill' is the
		# last command executed here if a signal is resent, this doesn't matter.)
	fi
}
# Wrapper function for 'eval' in _Msh_doTraps(): this makes 'return' in traps equivalent to 'exit'.
# Another benefit is that we can clear the positional parameters for the trap (with 'shift').
# (The trick is that the enveloping 'eval' has already expanded ${1} before 'shift' clears it.)
_Msh_doPosixTrap() {
	eval "shift 2; setstatus $2; eval \" \${_Msh_POSIXtrap${1}}\""
		#			    ^ QRK_EVALNOOPT compat: can't use '--' so use space for safe arbitrary commands.
		# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_19_16
}
# Same for a stack trap. Always run this in a subshell.
_Msh_doOneStackTrap() {
	# restore 'use safe'-related shell options stored by pushtrap
	eval "_Msh_doTraps_o=\${_Msh__V_Msh_trap${1}_opt__S${2}}"
	case ${-},${_Msh_doTraps_o} in (*f*,*f*) ;; (*f*,*) set +f;; (*,*f*) set -f;; esac
	case ${-},${_Msh_doTraps_o} in (*u*,*u*) ;; (*u*,*) set +u;; (*,*u*) set -u;; esac
	case ${-},${_Msh_doTraps_o} in (*C*,*C*) ;; (*C*,*) set +C;; (*,*C*) set -C;; esac
	# restore IFS stored by pushtrap
	if isset "_Msh__V_Msh_trap${1}_ifs__S${2}"; then
		eval "IFS=\${_Msh__V_Msh_trap${1}_ifs__S${2}}"
	else
		while isset IFS; do	# QRK_LOCALUNS/QRK_LOCALUNS2 compat
			IFS=' '		# BUG_KUNSETIFS compat
			unset -v IFS
		done
	fi
	# execute trap
	eval "shift 3; setstatus $3; eval \" \${_Msh__V_Msh_trap${1}__S${2}}\""
}

# Alias the builtin 'trap' command to a replacement to avoid overwriting other
# traps on the same signal. (Overriding 'trap' with a function doesn't work
# on every shell; an alias is more reliable.) This command should conform to:
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#trap
# with the exception that, for compatibility purposes, only an unsigned integer
# of 31 or less is interpreted as an argument to unset a trap.
alias trap='_Msh_POSIXtrap'
_Msh_POSIXtrap() {
	case ${#},${1-} in
	( 0, | 1,-- | *,-p | *,--print )
		# Print the traps, both legacy and stack.
		# (Sadly, something like _Msh_traps=$(trap) does not work on (d)ash, zsh and mksh/lksh: they do not support the
		# optional POSIX feature that avoids reseting traps in a subshell if 'trap' is the only command so we can read
		# traps from a command substitution subshell. We're forced to create a temporary file instead. Be atomic.)
		_Msh_trapd=$(unset -v _Msh_D _Msh_i
			umask 077
			until	_Msh_D=/tmp/_Msh_trapd.$$.${_Msh_i=${RANDOM:-0}}
				PATH=$DEFPATH command mkdir "${_Msh_D}" 2>/dev/null	# 'mkdir' is atomic
			do	let "$? > 125" && _Msh_doExit 1 "trap: system error: 'mkdir' could not be invoked or was killed"
				is -L dir /tmp && can write /tmp || _Msh_doExit 1 "trap: system error: /tmp directory not writable"
				_Msh_i=$(( ${RANDOM:-_Msh_i + 1} ))
			done
			: > "${_Msh_D}/systraps" || exit 1
			put "${_Msh_D}"
		) || die "trap: internal error: can't create temporary directory" || return
		# Write output of 'trap' builtin to temp file, checking command success and write success separately.
		{	command trap "$@" \
			|| eval "PATH=\$DEFPATH command rm -rf \"\${_Msh_trapd}\"; unset -v _Msh_trapd; return $?"
		} >| "${_Msh_trapd}/systraps" || die "trap: internal error: can't write to temp file" || return
		# Now we need to parse the system 'trap' output, generating shell-quoted commands suitable for execution
		# by the shell. It is possible for the third argument (the command to execute) to span multiple lines, so
		# just eval-ing them line by line won't work reliably. A more robust method is to alias 'trap' to a shell
		# function, which can easily parse the arguments and print both the stack traps and the POSIX traps.
		if is nonempty "${_Msh_trapd}/systraps"; then
			alias trap='_Msh_printSysTrap'
			command . "${_Msh_trapd}/systraps" || die "trap: internal error" || return
			alias trap='_Msh_POSIXtrap'
		fi
		# Cleanup.
		case $- in
		( *m* )	PATH=$DEFPATH command rm -rf "${_Msh_trapd}" ;;
		( * )	PATH=$DEFPATH command rm -rf "${_Msh_trapd}" & ;;
		esac
		unset -v _Msh_trapd
		# Print the ERR trap. On some shells, it is not inherited by functions.
		if _Msh_arg2sig ERR \
		&& { isset "_Msh_POSIXtrap${_Msh_sigv}" || ! stackempty "_Msh_trap${_Msh_sigv}"; } \
		&& ! isset _Msh_pT_alreadyPrinted_ERR; then
			_Msh_printSysTrap -- "_Msh_doTraps ERR ${_Msh_sigv}" ERR
		fi
		# Detect traps we missed. This makes the output of 'trap' work consistently in subshells, e.g. v=$(trap)
		_Msh_signum=-1
		while let "(_Msh_signum+=1)<128"; do
			_Msh_arg2sig "${_Msh_signum}" || continue
			if isset "_Msh_pT_alreadyPrinted_${_Msh_sigv}"; then
				unset -v "_Msh_pT_alreadyPrinted_${_Msh_sigv}"
				continue
			fi
			if isset "_Msh__V_Msh_trap${_Msh_sigv}__SP" || isset "_Msh_POSIXtrap${_Msh_sigv}"; then
				_Msh_printSysTrap -- "_Msh_doTraps ${_Msh_sig} ${_Msh_sigv}" "${_Msh_sig}"
			fi
		done
		# Print the DIE trap.
		if isset _Msh_POSIXtrapDIE || ! stackempty _Msh_trapDIE; then
			_Msh_printSysTrap -- '_Msh_doTraps DIE DIE' DIE
		fi
		unset -v _Msh_sig _Msh_sigv _Msh_signum _Msh_pT_alreadyPrinted_ERR _Msh_pT_alreadyPrinted_DIE
		return ;;
	( 1,-[!-]* | 1,--?* )
		# allow system-specific things such as "trap -l" (bash) or "trap --help" (ksh93, yash)
		command trap "$@"
		return ;;
	esac

	case $1 in
	( -- )	shift ;;
	esac

	case ${1-} in
	( '' | *[!0123456789]* ) ;;
	( * )	# First operand is unsigned integer: reset signals.
		set -- - "$@" ;;
	esac

	case ${#},$1 in
	( 1,* | *,- )
		# Emulation of system command to unset a trap.
		case ${#},$1 in
		( 1,- )	die 'trap (unset): signal specification expected' || return ;;
		( *,- )	shift ;;
		esac
		for _Msh_sig do
			if _Msh_arg2sig; then
				# a trap handled by the stack: be non-destructive
				if ! isset "_Msh__V_Msh_trap${_Msh_sigv}__SP" && ! identic "${_Msh_sig}" DIE; then
					identic "${_Msh_sig}" EXIT && _Msh_sig=0  # BUG_TRAPEXIT compat
					command trap - "${_Msh_sig}" || die "trap (unset): builtin 'trap' failed" || return
				fi
				unset -v "_Msh_POSIXtrap${_Msh_sigv}" _Msh_sig _Msh_sigv
			else
				die "trap (unset): invalid signal: '${_Msh_sig}'" || return
			fi
		done ;;
	( * )	# Emulation of system command to set a trap.
		case $# in
		( 1 )	die "trap (set): at least one signal specification expected" || return ;;
		esac
		_Msh_trap_CMD=$1
		shift
		for _Msh_sig do
			if _Msh_arg2sig; then
				# a trap handled by the stack: play nice with it
				case ${_Msh_sig} in
				(DIE)	;;
				(EXIT)	command trap "_Msh_doTraps ${_Msh_sig} ${_Msh_sigv}" 0 ;;  # BUG_TRAPEXIT compat
				( * )	command trap "_Msh_doTraps ${_Msh_sig} ${_Msh_sigv}" "${_Msh_sig}" ;;
				esac || die "trap (set): builtin 'trap' failed" || return
				eval "_Msh_POSIXtrap${_Msh_sigv}=\${_Msh_trap_CMD}"
			else
				die "trap (set): invalid signal: '${_Msh_sig}'" || return
			fi
		done
		unset -v _Msh_trap_CMD _Msh_sig _Msh_sigv ;;
	esac
}

# Internal function to interpret the output of the system 'trap' command with no operands.
# We're parsing 'trap' arguments as specified here:
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_28_03
_Msh_printSysTrap() {
	case ${#},${1-} in
	(2,--)	if thisshellhas BUG_TRAPEMPT "--sig=$2"; then
			# pdksh/mksh fails to quote empty trap actions.
			set -- "$1" "" "$2"
		elif identic "$2" "_Msh_doTraps EXIT EXIT"; then
			# Workaround for intermittent bug on zsh 5.0.7 and 5.0.8. TODO: remove when support stops.
			# With this bug, the 'trap' builtin sometimes does not print the EXIT pseudosignal name.
			set -- "$1" "$2" "EXIT"
		fi ;;
	esac
	case ${#},${1-} in
	( 3,-- ) ;;
	( * )	die "trap: internal error: unexpected output of system 'trap' command" || return ;;
	esac
	case $2 in
	( "_Msh_doTraps "* )
		# this trap was set by a modernish function
		_Msh_sig=${2#*Msh_d* }
		_Msh_sigv=${_Msh_sig#* }
		_Msh_sig=${_Msh_sig% *}
		unset -v _Msh_pT_cmd
		if isset "_Msh__V_Msh_trap${_Msh_sigv}__SP"; then
			# print the traps set by 'pushtrap'
			_Msh_pT_i=-1
			while let "(_Msh_pT_i+=1) < _Msh__V_Msh_trap${_Msh_sigv}__SP"; do
				eval "_Msh_pT_cmd=\${_Msh__V_Msh_trap${_Msh_sigv}__S${_Msh_pT_i}}"
				shellquote -f _Msh_pT_cmd
				if isset "_Msh__V_Msh_trap${_Msh_sigv}__K${_Msh_pT_i}"; then
					eval "_Msh_pT_key=\${_Msh__V_Msh_trap${_Msh_sigv}__K${_Msh_pT_i}}"
					shellquote _Msh_pT_key
					putln "pushtrap --key=${_Msh_pT_key} -- ${_Msh_pT_cmd} ${_Msh_sig}"
				else
					putln "pushtrap -- ${_Msh_pT_cmd} ${_Msh_sig}"
				fi
			done
			unset -v _Msh_pT_i
		fi
		if isset "_Msh_POSIXtrap${_Msh_sigv}"; then
			# print the trap set by the emulated POSIX 'trap' command
			eval "_Msh_pT_cmd=\${_Msh_POSIXtrap${_Msh_sigv}}"
			shellquote -f _Msh_pT_cmd
			putln "trap -- ${_Msh_pT_cmd} ${_Msh_sig}"
		fi
		# if there are neither, but still an _Msh_doTraps system trap, it would do nothing, so...
		if ! isset _Msh_pT_cmd; then
			putln "trap -- '' ${_Msh_sig}"	# ... reflect that the signal is being ignored
		fi ;;
	( * )	# this trap was set directly by the system command
		_Msh_arg2sig "$3" || die "trap: internal error: invalid trap name: ${_Msh_sig}" || return
		if ! insubshell; then
			# Bring it into the modernish fold so 'pushtrap' won't overwrite it.
			case ${_Msh_sig} in
			(EXIT)	command trap "_Msh_doTraps ${_Msh_sig} ${_Msh_sigv}" 0 ;;  # BUG_TRAPEXIT compat
			( * )	command trap "_Msh_doTraps ${_Msh_sig} ${_Msh_sigv}" "${_Msh_sig}" ;;
			esac && eval "_Msh_POSIXtrap${_Msh_sigv}=\$2"
		fi
		_Msh_pT_cmd=$2
		shellquote -f _Msh_pT_cmd
		putln "trap -- ${_Msh_pT_cmd} ${_Msh_sig}" ;;
	esac
	eval "_Msh_pT_alreadyPrinted_${_Msh_sigv}="
	unset -v _Msh_pT_cmd _Msh_pT_key _Msh_sig _Msh_sigv
}

# -------------

# harden: modernish's replacement for 'set -e' (errexit)
#
# Function that installs a function to harden commands by testing their exit
# status against values indicating error or system failure. Upon failure,
# 'harden' calls 'die', so it will reliably halt program execution, even if
# the failure occurred within a subshell (for instance, in a pipe construct
# or command substitution). Also supports highlighted tracing of the command.
#
# Usage: harden [ -f <funcname> ] [ -[cpXtPE] ] [ -e <testexpr> ] \
#	[ <var=value> ... ] [ -u <var> ... ] <cmdname/path> [ <arg> ... ]
#
# The <testexpr> is like a shell arithmetic expression, with the binary
# operators '==' '!=' '<=' '>=' '<' '>' turned into unary operators.
# Everything else is the same, including && and || and parentheses.
# What exit status indicates failure depends on the command. For standard
# commands, refer to the POSIX standard. For others, see their manual pages.
#
# <var=value> assignments cause corresponding environment variables to be
# exported with the values indicated for the duration of the command. If the
# command is a shell function, this will cause it to be run in a subshell.
# Assignments override corresponding unset (-u) options, even subsequent ones.
#
# Options:
#	-f: Harden the command as the function with name <funcname> instead
#	    of a name identical to <cmdname/path>.
#	    To harden a shell function, a command with full pathname,
#	    or any command with a name that would be invalid for a shell
#	    function, use the -f option harden it under a different name.
#	-c: One-time hardening. Instead of setting a shell function, harden
#	    and run <cmdname/path> immediately. Cannot be used with -f.
#	-p: Use system default path instead of current $PATH to find
#	    external commands (akin to POSIX 'command -p').
#	    When given twice, or if <cmdname/path> is a shell function,
#	    also export PATH=$DEFPATH before running <cmdname/path>.
#	-X: Bypass builtins, always use external command.
#	-P: Do not die if the command is killed by a broken pipe.
#	-t: Trace the command (uses file descriptor 9).
#	-e: Specify exit status test expression as explained above.
#	    Defaults to '>0'.
#	-E: Die if the command writes anything to standard error.
#	    (Causes the command to be run in a subshell.)
#	-u: Unset a shell or environment variable for the duration of the command.
#	    (Causes the command to be run in a subshell.)
#
# Usage examples:
#	harden -e '> 1' grep			# grep fails on exit status > 1
#	harden -e '>= 2' grep			# equivalent to the above
#	harden -e '==1 || >2' gzip		# 1 and >2 are errors, but 2 isn't (see 'man gzip')
#	harden -f findWord -Pe '>1' grep -w	# hardened function 'findWord' uses 'grep -w', tolerating SIGPIPE
unset -v _Msh_Ht_R _Msh_Ht_y _Msh_Ht_r _Msh_Ht_b  # for storing (t)erminal codes for (t)racing
unset -v _Msh_H_C  # function name for error messages (default: 'harden')
harden() {
	_Msh_H_C=${_Msh_H_C-harden}
	# ___begin option & assignment argument parser____
	unset -v _Msh_Ho_P _Msh_Ho_t _Msh_Ho_c _Msh_Ho_X _Msh_Ho_e _Msh_Ho_f _Msh_Ho_u _Msh_H_V _Msh_H_VA
	_Msh_Ho_p=0	# count how many times '-p' was specified
	while :; do
		case ${1-} in
		( [!-]*=* ) # environment variable assignment
			isvarname "${1%%=*}" || break
			isset -r "${1%%=*}" && { die "${_Msh_H_C}: read-only variable: ${1%%=*}" || return; }
			_Msh_H_QV=${1#*=}
			shellquote _Msh_H_QV
			_Msh_H_VA=${_Msh_H_VA:+$_Msh_H_VA }${1%%=*}=${_Msh_H_QV}
			_Msh_H_V=${_Msh_H_V:+$_Msh_H_V }${1%%=*}
			unset -v _Msh_H_QV ;;
		( -[!-]?* ) # split a set of combined options
			_Msh_Ho__o=${1#-}
			shift
			while :; do
				case ${_Msh_Ho__o} in
				( '' )	break ;;
				# if the option requires an argument, split it and break out of loop
				# (it is always the last in a combined set)
				( [euf]* )
					_Msh_Ho__a=-${_Msh_Ho__o%"${_Msh_Ho__o#?}"}
					push _Msh_Ho__a
					_Msh_Ho__o=${_Msh_Ho__o#?}
					if ! empty "${_Msh_Ho__o}"; then
						_Msh_Ho__a=${_Msh_Ho__o}
						push _Msh_Ho__a
					fi
					break ;;
				esac
				# split options that do not require arguments (and invalid options) until we run out
				_Msh_Ho__a=-${_Msh_Ho__o%"${_Msh_Ho__o#?}"}
				push _Msh_Ho__a
				_Msh_Ho__o=${_Msh_Ho__o#?}
			done
			while pop _Msh_Ho__a; do
				set -- "${_Msh_Ho__a}" "$@"
			done
			unset -v _Msh_Ho__o _Msh_Ho__a
			continue ;;
		( -[cXtPE] )
			eval "_Msh_Ho_${1#-}=''" ;;
		( -p )	let "_Msh_Ho_p += 1" ;;
		( -[ef] )
			let "$# > 1" || die "${_Msh_H_C}: $1: option requires argument" || return
			eval "_Msh_Ho_${1#-}=\$2"
			shift ;;
		( -u )	let "$# > 1" || die "${_Msh_H_C}: $1: option requires argument" || return
			isvarname "$2" || die "${_Msh_H_C} -u: invalid variable name: $2" || return
			_Msh_Ho_u=${_Msh_Ho_u:+$_Msh_Ho_u }$2
			shift ;;
		( -- )	shift; break ;;
		( -* )	die "${_Msh_H_C}: invalid option: $1" || return ;;
		( * )	break ;;
		esac
		shift
	done
	# ^^^end option & assignment argument parser^^^

	case $# in
	( 0 )	die "${_Msh_H_C}: command expected${CCn}" \
			"usage: harden [ -f <funcname> ] [ -[cptP] ] [ -e <testexpr> ] \\${CCn}" \
			"${CCt}[ <var=value> ... ] [ -u <var> ... ] <cmdname/path> [ <arg> ... ]" || return ;;
	esac

	if isset _Msh_Ho_c; then
		if isset _Msh_Ho_f; then
			die "harden: -c cannot be used with -f" || return
		fi
		_Msh_Ho_f="_Msh_harden_tmp"	# temp function name
	elif ! isset _Msh_Ho_f; then
		_Msh_Ho_f=$1
	fi

	if isset _Msh_Ho_X; then
		if let "_Msh_Ho_p > 0"; then
			_Msh_H_cmd=$(extern -pv -- "$1")
		else
			_Msh_H_cmd=$(extern -v -- "$1")
		fi
	else
		if let "_Msh_Ho_p > 0"; then
			_Msh_H_cmd=$(command unalias "$1"; PATH=$DEFPATH; command -v -- "$1")
		else
			_Msh_H_cmd=$(command unalias "$1"; command -v -- "$1")
		fi
	fi 2>/dev/null

	case ${_Msh_H_cmd} in
	( '' )	if let "_Msh_Ho_p > 0"; then
			die "${_Msh_H_C}: ${_Msh_Ho_X+external }command not found in system default path: '$1'"
		else
			die "${_Msh_H_C}: ${_Msh_Ho_X+external }command not found: '$1'"
		fi || return ;;
	esac
	case ${_Msh_Ho_f} in
	(\!|\{|\}|case|do|done|elif|else|\esac|fi|for|if|in|then|until|while \
	|break|:|continue|.|eval|exec|exit|export|readonly|return|set|shift|times|trap|unset)
		# blacklist POSIX reserved words and special builtins
		die "${_Msh_H_C}: can't harden POSIX reserved word or special builtin '${_Msh_Ho_f}'" || return ;;
	( '' | [0123456789]* | *[!"$ASCIIALNUM"_]* )
		die "${_Msh_H_C}: invalid shell function name: ${_Msh_Ho_f}" || return
		;;
	esac
	if thisshellhas "--rw=${_Msh_Ho_f}"; then
		die "${_Msh_H_C}: can't harden reserved word '${_Msh_Ho_f}'" || return
	elif alias "${_Msh_Ho_f}" >/dev/null 2>&1; then
		die "${_Msh_H_C}: function name '${_Msh_Ho_f}' conflicts with alias '${_Msh_Ho_f}'" || return
	elif ! isset _Msh_Ho_c; then
		if isset -f "${_Msh_Ho_f}"; then
			die "${_Msh_H_C}: shell function already exists: ${_Msh_Ho_f}" || return
		fi
		if thisshellhas "--bi=${_Msh_Ho_f}"; then
			# check if builtin is overrideable
			(eval "${_Msh_Ho_f}() { :; }") 2>/dev/null || die "${_Msh_H_C}: can't harden '${_Msh_Ho_f}'" || return
		fi
	fi

	unset -v _Msh_H_isFunc
	case ${_Msh_H_cmd} in
	( "${_Msh_Ho_f}" )
		# Got shell built-in command.
		_Msh_H_cmd="command ${_Msh_H_cmd}"
		;;
	( /* )	shellquote _Msh_H_cmd   # in case of weird path names
		if isset _Msh_Ho_u || isset _Msh_Ho_E; then
			# command will be run from a subshell
			_Msh_H_cmd="exec ${_Msh_H_cmd}"
		fi
		;;
	( */* )	# Relative path name: make absolute (defeating linefeed stripping from cmd subst)
		_Msh_E=$(command cd "${_Msh_H_cmd%/*}" &&
			command pwd &&
			put X) || die "${_Msh_H_C}: internal error" || return
		_Msh_H_cmd=${_Msh_E%${CCn}X}/${_Msh_H_cmd##*/}
		shellquote _Msh_H_cmd
		if isset _Msh_Ho_u || isset _Msh_Ho_E; then
			_Msh_H_cmd="exec ${_Msh_H_cmd}"
		fi
		;;
	( * )	if alias "${_Msh_H_cmd}" >/dev/null 2>&1; then
			# Hardening aliases is too risky. It basically amounts to using 'eval' with untrusted
			# and unvalidated input. Aliases could contain any combination of shell grammar and
			# compound commands, so they could easily mess up the hardening function.
			die "${_Msh_H_C}: aliases are not supported: ${_Msh_H_cmd}" || return
		elif thisshellhas "--rw=${_Msh_H_cmd}"; then
			die "${_Msh_H_C}: can't harden reserved word '${_Msh_H_cmd}'" || return
		elif isset -f "${_Msh_H_cmd}"; then
			_Msh_H_isFunc=y
		elif thisshellhas "--bi=${_Msh_H_cmd}"; then
			_Msh_H_cmd="command -- ${_Msh_H_cmd}"
		else	# this should never happen
			die "${_Msh_H_C}: internal error" || return
		fi
		;;
	esac

	# two '-p' options, or shell function and one '-p' option: also export PATH=$DEFPATH for this command
	if let "_Msh_Ho_p > 1" || { isset _Msh_H_isFunc && let "_Msh_Ho_p > 0"; }; then
		_Msh_H_VA=${_Msh_H_VA:+$_Msh_H_VA }PATH=\$DEFPATH
		_Msh_H_V=${_Msh_H_V:+$_Msh_H_V }PATH
	fi

	# add any extra command arguments (e.g. options)
	shift
	for _Msh_E do
		shellquote _Msh_E
		_Msh_H_cmd=${_Msh_H_cmd}\ ${_Msh_E}
	done

	# if caller asked to trace the hardened command, store relevant commands in option variable _Msh_Ho_t
	if isset _Msh_Ho_t; then
		{ command : >&9; } 2>/dev/null || exec 9>&2
		if ! isset _Msh_Ht_R && is onterminal 9; then
			if _Msh_Ht_R=$(PATH=$DEFPATH command tput sgr0); then
				# tput uses terminfo capnames (most OSes)
				_Msh_Ht_y=${_Msh_Ht_R}$(PATH=$DEFPATH; command tput setaf 3 || command tput dim)
				_Msh_Ht_r=${_Msh_Ht_R}$(PATH=$DEFPATH; command tput setaf 1 || command tput smul)
				_Msh_Ht_b=${_Msh_Ht_R}$(PATH=$DEFPATH; command tput setaf 4; command tput bold)
			elif _Msh_Ht_R=$(PATH=$DEFPATH command tput me); then
				# tput uses termcap codes (FreeBSD)
				_Msh_Ht_y=${_Msh_Ht_R}$(PATH=$DEFPATH; command tput AF 3 || command tput mh)
				_Msh_Ht_r=${_Msh_Ht_R}$(PATH=$DEFPATH; command tput AF 1 || command tput us)
				_Msh_Ht_b=${_Msh_Ht_R}$(PATH=$DEFPATH; command tput AF 4; command tput md)
			else	# we got nothing
				_Msh_Ht_R=''
			fi
		fi 2>/dev/null
		if is onterminal 9 && ! empty "${_Msh_Ht_R}"; then
			# highlight trace in red, yellow and blue with fallback to monochrome highlighting
			_Msh_Ho_t="putln \"\${_Msh_Ht_y}[\${_Msh_Ht_r}"
			isset _Msh_Ho_c && _Msh_Ho_t=${_Msh_Ho_t}${_Msh_H_C} || _Msh_Ho_t=${_Msh_Ho_t}${_Msh_Ho_f}
			_Msh_Ho_t="${_Msh_Ho_t}\${_Msh_Ht_y}]> \${_Msh_Ht_b}\${_Msh_P}\${_Msh_Ht_R}\" 1>&9"
		else	# default
			_Msh_Ho_t="putln \"["
			isset _Msh_Ho_c && _Msh_Ho_t=${_Msh_Ho_t}${_Msh_H_C} || _Msh_Ho_t=${_Msh_Ho_t}${_Msh_Ho_f}
			_Msh_Ho_t="${_Msh_Ho_t}]> \${_Msh_P}\" 1>&9"
		fi
	fi

	# command to store command + positional parameters shellquoted in _Msh_P
	eval "set -- ${_Msh_H_cmd}"  # count number of fixed arguments (cmd is already shellquoted; 'eval' is safe)
	_Msh_H_spp="_Msh_doStoreParams \"\$((\${#}+${#}))\" ${_Msh_H_cmd} \"\$@\" _Msh_P"

	# add hardening function's positional parameters as arguments to the real command
	_Msh_H_cmd=${_Msh_H_cmd}' "$@"'

	# If we have variables to export or unset, and/or the command needs a subshell, add them now.
	if isset _Msh_Ho_u || isset _Msh_Ho_E || isset _Msh_H_isFunc; then
		# We have to run it in a ( subshell ) with any indicated variables unset and/or exported.
		#   [Note: we cannot generate assignment arguments to 'export' (export foo=bar) because, on
		#   basic POSIX shells, those are subject to field splitting and globbing. So generate the
		#   assignments and the 'export' command separately.]
		_Msh_E=${_Msh_Ho_u:+unset -v $_Msh_Ho_u; }${_Msh_H_VA:+$_Msh_H_VA; }${_Msh_H_V:+export $_Msh_H_V; }
		if isset _Msh_Ho_E; then
			# Capture standard error and die if anything is written to it.
			_Msh_H_cmd="{ _Msh_e=\$(set +x; ${_Msh_E}${_Msh_H_cmd} 2>&1 1>&9); } 9>&1 && case \${_Msh_e} in (?*) ! : ;; esac"
			_Msh_Ho_E="case \${_Msh_e} in (?*) die \"${_Msh_Ho_f}: command wrote error: \${_Msh_P}\${CCn}\${_Msh_e}\" ;; esac"
		else
			_Msh_H_cmd="( ${_Msh_E}${_Msh_H_cmd} )"
		fi
		# ...for tracing and error messages:
		_Msh_E="( ${_Msh_E}"
		shellquote _Msh_E
		_Msh_H_spp="${_Msh_H_spp} && _Msh_P=${_Msh_E}\${_Msh_P}' )'"
	elif isset _Msh_H_V; then
		# If it's a builtin or external command, and we have nothing to unset, we can use
		# the shell grammar's mechanism for temporarily assigning variables to export.
		_Msh_E="${_Msh_H_VA} "
		_Msh_H_cmd="${_Msh_E}${_Msh_H_cmd}"
		# ...for tracing and error messages:
		shellquote _Msh_E
		_Msh_H_spp="${_Msh_H_spp} && _Msh_P=${_Msh_E}\${_Msh_P}"
	fi

	# determine status checking method and set hardening function
	if	case ${_Msh_Ho_e='>0'} in
		( '>0' | '> 0' | '>=1' | '>= 1' | '!=0' | '!= 0' ) ;;
		( * ) ! : ;;
		esac &&
		! isset _Msh_Ho_P
	then	# For efficiency, handle a simple non-zero check specially.
		if isset _Msh_Ho_t; then
			eval "${_Msh_Ho_f}() {
				${_Msh_H_spp}
				${_Msh_Ho_t}
				${_Msh_H_cmd} && unset -v _Msh_P${_Msh_Ho_E+ _Msh_e} || {
					_Msh_E=\$?
					if let '_Msh_E>128' && thisshellhas \"--sig=\${_Msh_E}\"; then
						_Msh_P=\"killed by SIG\$REPLY: \${_Msh_P}\"
					fi
					${_Msh_Ho_E-}
					die \"${_Msh_Ho_c-${_Msh_Ho_f}: }failed with status \${_Msh_E}: \${_Msh_P}\"
					eval \"unset -v _Msh_P _Msh_E${_Msh_Ho_E+ _Msh_e}; return \${_Msh_E}\"
				}
			}${CCn}"
		else
			eval "${_Msh_Ho_f}() {
				${_Msh_H_cmd}${_Msh_Ho_E+ && unset -v _Msh_e} || {
					_Msh_E=\$?
					${_Msh_H_spp}
					if let '_Msh_E>128' && thisshellhas \"--sig=\${_Msh_E}\"; then
						_Msh_P=\"killed by SIG\$REPLY: \${_Msh_P}\"
					fi
					${_Msh_Ho_E-}
					die \"${_Msh_Ho_c-${_Msh_Ho_f}: }failed with status \${_Msh_E}: \${_Msh_P}\"
					eval \"unset -v _Msh_P _Msh_E${_Msh_Ho_E+ _Msh_e}; return \${_Msh_E}\"
				}
			}${CCn}"
		fi
	else	# Translate the status check expression to an arithmetic expression:
		# unary operators become binary operators with _Msh_E on the left hand
		case ${_Msh_Ho_e} in
		( =[!=]* | *[!!\<\>=]=[!=]* | *[%*/+-]=* | *--* | *++* )
			die "${_Msh_H_C}: assignment not allowed in status expression: '${_Msh_Ho_e}'" || return ;;
		( *[=\<\>]* ) ;;
		( * )	die "${_Msh_H_C}: unary comparison operator required in status expression: '${_Msh_Ho_e}'" || return ;;
		esac
		_Msh_H_expr=${_Msh_Ho_e}
		for _Msh_H_c in '<' '>' '==' '!='; do
			# use a temporary variable to avoid an infinite loop when
			# replacing all of one character by one or more of itself
			# (algorithm from 'replacein' in var/string.mm)
			_Msh_H_nwex=${_Msh_H_expr}
			_Msh_H_expr=
			while contains "${_Msh_H_nwex}" "${_Msh_H_c}"; do
				_Msh_H_expr=${_Msh_H_expr}${_Msh_H_nwex%%"${_Msh_H_c}"*}\(_Msh_E\)${_Msh_H_c}
				_Msh_H_nwex=${_Msh_H_nwex#*"${_Msh_H_c}"}
			done
			_Msh_H_expr=${_Msh_H_expr}${_Msh_H_nwex}
		done
		unset -v _Msh_H_nwex _Msh_H_c
		if isset _Msh_Ho_P; then
			_Msh_H_expr="(${_Msh_H_expr}) && _Msh_E!=$SIGPIPESTATUS"
		fi
		_Msh_E=0
		( : "$((${_Msh_H_expr}))" ) 2>/dev/null || die "${_Msh_H_C}: invalid status expression: '${_Msh_Ho_e}'" || return
		let "${_Msh_H_expr}" && { die "${_Msh_H_C}: success means failure in status expression: ${_Msh_Ho_e}" || return; }

		# Set the hardening function.
		isset _Msh_Ho_E && _Msh_H_expr=\(${_Msh_H_expr}') || ${#_Msh_e}>0'
		shellquote _Msh_H_expr
		if isset _Msh_Ho_t; then
			eval "${_Msh_Ho_f}() {
				${_Msh_H_spp}
				${_Msh_Ho_t}
				${_Msh_H_cmd} && unset -v _Msh_P${_Msh_Ho_E+ _Msh_e} || {
					_Msh_E=\$?
					if let ${_Msh_H_expr}; then
						if let '_Msh_E>128' && thisshellhas \"--sig=\${_Msh_E}\"; then
							_Msh_P=\"killed by SIG\$REPLY: \${_Msh_P}\"
						fi
						${_Msh_Ho_E-}
						die \"${_Msh_Ho_c-${_Msh_Ho_f}: }failed with status \${_Msh_E}: \${_Msh_P}\"
					fi
					eval \"unset -v _Msh_P _Msh_E${_Msh_Ho_E+ _Msh_e}; return \${_Msh_E}\"
				}
			}${CCn}"
		else
			eval "${_Msh_Ho_f}() {
				${_Msh_H_cmd}${_Msh_Ho_E+ && unset -v _Msh_e} || {
					_Msh_E=\$?
					if let ${_Msh_H_expr}; then
						${_Msh_H_spp}
						if let '_Msh_E>128' && thisshellhas \"--sig=\${_Msh_E}\"; then
							_Msh_P=\"killed by SIG\$REPLY: \${_Msh_P}\"
						fi
						${_Msh_Ho_E-}
						die \"${_Msh_Ho_c-${_Msh_Ho_f}: }failed with status \${_Msh_E}: \${_Msh_P}\"
					fi
					eval \"unset -v _Msh_P _Msh_E${_Msh_Ho_E+ _Msh_e}; return \${_Msh_E}\"
				}
			}${CCn}"
		fi
	fi

	eval "unset -v _Msh_Ho_c _Msh_Ho_X _Msh_Ho_e _Msh_Ho_f _Msh_Ho_p _Msh_Ho_t _Msh_Ho_u _Msh_Ho_E _Msh_H_V _Msh_H_VA \
			_Msh_E _Msh_H_C _Msh_H_cmd _Msh_H_expr _Msh_H_isFunc _Msh_H_spp
		${_Msh_Ho_c+_Msh_harden_tmp}"
}

# trace: use 'harden' to trace a command with minimal hardening, i.e.: harden only against system errors
# and signals (except SIGPIPE), not command errors. It's just a convenience function that does nothing you
# can't already do with 'harden', but it's trivial to implement, so the extra convenience is worth it.
# Any options are passed on to 'harden'.
trace() {
	case $# in
	( 0 )	die "trace: command expected${CCn}" \
			"usage: trace [ -f <funcname> ] [ -[cp] ] \\${CCn}" \
			"${CCt}[ <var=value> ... ] [ -u <var> ... ] <cmdname/path> [ <arg> ... ]" || return ;;
	esac
	_Msh_H_C=trace  # command name for harden() error messages
	harden -t -P -e '>125 && !=255' "$@"
}

# -------------

# 'putln' and 'put'
#
# 'putln' prints each argument on a separate line. 'put' prints all arguments,
# separated by spaces, without a trailing newline. There is no processing of
# options, '--', escape codes, or any other potential pitfalls.
#
# These functions are the modernish replacement for 'echo', which is deprecated.
# POSIX: "It is not possible to use echo portably across all POSIX systems
# unless both -n (as the first argument) and escape sequences are omitted."
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/echo.html#tag_20_37_16

if thisshellhas print KSH88FUNC; then
	# pdksh and mksh don't have a 'printf' builtin, and using the external
	# 'printf' command is very slow. But they do have a built-in
	# ksh/zsh-style 'print' command, so here are versions of 'putln' and
	# 'put' that take advantage of it to get much higher performance.
	putln() {
		case $# in
		( 0 )	command print ;;
		( 1 )	command print -r -- "$1" ;;
		( * )	typeset IFS="$CCn" && command print -r -- "$*" ;;
		esac || { let "$? > 1" && die "putln: internal error"; }
	}

	put() {
		case ${#},${1-} in
		( [01], ) ;;
		( 1,* )  command print -nr -- "$1" ;;
		( * )	 typeset IFS=' ' && command print -nr -- "$*" ;;
		esac || { let "$? > 1" && die "put: internal error"; }
	}

else
	# For most shells, use 'printf' for putln and put.
	putln() {
		case $# in
		( 0 )	PATH=$DEFPATH command printf '\n' ;;
		( * )	PATH=$DEFPATH command printf '%s\n' "$@" ;;
		esac || { let "$? > 1" && die "putln: internal error"; }
	}

	if thisshellhas LOCAL local; then
		# bash, ash variants, zsh
		put() {
			case ${#},${1-} in
			( [01], ) ;;
			( 1,* )  PATH=$DEFPATH command printf '%s' "$1" ;;
			( * )	 local IFS=' ' && PATH=$DEFPATH command printf '%s' "$*" ;;
			esac || { let "$? > 1" && die "put: internal error"; }
		}
	elif thisshellhas KSH93FUNC || thisshellhas KSH88FUNC; then
		# AT&T ksh93; yash (non-posixlycorrect)
		# On ksh93, local variables are only supported on functions
		# defined with the 'function' keyword. Use 'eval' to avoid
		# syntax error on shells without that keyword.
		eval 'function put {
			case ${#},${1-} in
			( [01], ) ;;
			( 1,* )  PATH=$DEFPATH command printf "%s" "$1" ;;
			( * )	 typeset IFS=" " && PATH=$DEFPATH command printf "%s" "$*" ;;
			esac || { let "$? > 1" && die "put: internal error"; }
		}'
	else
		# default (POSIX, no local variables)
		put() {
			case ${#},${1-} in
			( [01], ) ;;
			( 1,* )  PATH=$DEFPATH command printf '%s' "$1" ;;
			( * )	 push IFS; IFS=' '
				 PATH=$DEFPATH command printf '%s' "$*"
				 pop --keepstatus IFS ;;
			esac || { let "$? > 1" && die "put: internal error"; }
		}
	fi
fi

# -------------

# 'source' as in zsh and bash, with optional positional parameters, now also
# available to (d)ash, yash and *ksh*. If extra arguments are given, they
# are passed to the dot script as local positional parameters as in a shell
# function; if not, the dot script inherits the calling environment's
# positional parameters (unlike a shell function).
#
# In pure POSIX shells, '.' cannot pass extra arguments, and dot scripts
# always inherit the caller's positional parameters; this can be worked
# around with a shell function. However, this is implementation-dependent;
# in bash, *ksh* and zsh, '.' does pass the parameters. Modernish scripts
# should use 'source' instead of '.' for consistent functionality.
if ! thisshellhas source; then
	alias source='_Msh_doSource "$#" "$@"'
	_Msh_doSource() {
		let "$# > ( $1 + 1 )" || _Msh_dieArgs source 0 'at least 1' || return
		eval "_Msh_source_S=\${$(( $1 + 2 ))}"

		if let "$# > ( $1 + 2 )"; then
			# extra arguments were given; discard the number of caller's positional parameters, the
			# caller's positional parameters themselves, and the argument indicating the dot script
			shift "$(( $1 + 2 ))"
		else
			# no extra arguments were given; keep caller's positional parameters, but remove the number
			# of them (first parameter) and the argument indicating the dot script (last parameter)
			_Msh_source_P=''
			_Msh_source_i=1
			while let "(_Msh_source_i+=1) < $#"; do
				_Msh_source_P="${_Msh_source_P} \"\${${_Msh_source_i}}\""
			done
			eval "set -- ${_Msh_source_P}"
			unset -v _Msh_source_P _Msh_source_i
		fi

		# Unlike '.', find the dot script in the current directory, not just in $PATH.
		case ${_Msh_source_S} in
		( */* ) ;;
		( * )	if is -L reg "${_Msh_source_S}"; then
				_Msh_source_S=./${_Msh_source_S}
			fi ;;
		esac

		. "${_Msh_source_S}"
		eval "unset -v _Msh_source_S; return $?"
	}
fi

# -------------

# On pure POSIX shells, though we can accomplish a lot with 'case' and shell
# arithmetic, some of the functions below will still depend on 'test'/'['.
# So, to mitigate the risk of 'test'/'[' brittleness causing programs to
# continue in an inconsistent state, harden the 'test' command. Legacy
# scripts using 'test' (as opposed to '[') will benefit as well.
if thisshellhas BUG_TESTILNUM; then
	# On dash, BUG_TESTILNUM causes test/[ to be misparsed one subsequent
	# time after it is called with an invalid number (e.g. [ -t X ]). So,
	# as a workaround, we need a dummy invocation of '[' to restore correct
	# parsing. (Remember that die() does not kill interactive shells, so
	# unbreaking '[' is still useful.)
	_Msh_test_TESTILNUM='PATH=$DEFPATH [ 2 -gt 1 ] 2>/dev/null'
else
	_Msh_test_TESTILNUM=''
fi
eval 'test() {
	PATH=$DEFPATH command test "$@" \
	|| ! case $? in
		( 1 )	;;
		( * )	'"${_Msh_test_TESTILNUM}"'
			shellquoteparams
			die "command failed: test $@" || return ;;
	esac
}'"${CCn}"
unset -v _Msh_test_TESTILNUM

# -------------

# Safer replacement functions for 'test'/'[', which is hereby deprecated
# for legibility, usability and security reasons.

# ---- Arithmetic tests and operations. ----

# Implementation of 'let' as in ksh, bash, zsh and busybox ash, for shells
# without it.
# Usage: let <expr> [ <expr> ... ]
# where <expr> is an arithmetic expression as in $(( ... )).
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_04
#
# The exit status is 1 if the last expression evaluates to 0, and 0 if not.
# (0 and 1 in C-style boolean are the opposite of 0 and 1 in shell boolean, so
# this means it does the right true-or-false thing for the shell.)
#
# NOTE: the prefix and postfix "++" and "--" operators are NOT required by
# POSIX and not portable. The ID 'ARITHPP' is assigned to this feature, so
# if you want to use ++/-- you should first check if "thisshellhas ARITHPP".
# Otherwise, for example, instead of 'let X++', use 'let X+=1'.
#
# Shells immediately exit on arith evaluation error, so the usual "|| die"
# check on errors is ineffective.
#
# There are two portability problems with 'let' builtins:
#   1.	On AT&T ksh, the first expression cannot start with a '-' as it will
#	be interpreted as an option, even though its "let" doesn't have any
#	valid options. The end-of-options delimeter '--' is needed for the
#	first expression to start with '-'. However, on pdksh/mksh and
#	Busybox ash, '--' is not accepted and will throw a syntax error.
#	These situations are irreconcilable without a workaround.
#	(Bash and zsh accept '--' but don't require them, even if the first
#	expression starts with '-'.)
#   2.  Some ash derivatives (such as FreeBSD /bin/sh) have an undocumented
#	and incompatible 'let' builtin that only takes one expression (and
#	uselessly outputs the result to standard output).
# So let's test if we have a version that works as expected and override the
# builtin if it's not up to scratch.
unset -v _Msh_X _Msh_Y _Msh_goodlet
if thisshellhas let; then
	if let -- -1\<0 _Msh_X=1 _Msh_Y=_Msh_X+3 \
	&& case ${_Msh_X-},${_Msh_Y-} in ( 1,4 ) ;; ( * ) false ;; esac \
	&& unset -v _Msh_X _Msh_Y
	then
		# Workaround for AT&T ksh to make things like 'let -1==var' or 'let --var' work.
		# For consistency, also use '--' on other shells whose 'let' builtin supports it;
		# this makes sure 'let' in modernish scripts does not accept '--' on any shell,
		# instead of accepting it on some shells but not on others.
		alias let='let --'
		_Msh_goodlet=y
	elif let -1\<0 _Msh_X=1 _Msh_Y=_Msh_X+3 \
	&& case ${_Msh_X-},${_Msh_Y-} in ( 1,4 ) ;; ( * ) false ;; esac \
	&& unset -v _Msh_X _Msh_Y
	then
		# Use the builtin as is: mksh/lksh, Busybox ash
		_Msh_goodlet=y
	fi
fi 2>/dev/null
case ${_Msh_goodlet+s} in
( s )	if let 014!=12 && thisshellhas -o letoctal; then
		set -o letoctal  # make AT&T ksh act like other shells
	fi
	unset -v _Msh_goodlet ;;
( * )	# We're on a shell with a missing or incompatible 'let' builtin, so provide our own.
	# Speed-optimize it by processing up to 8 expressions at once. (Quoting the parameters
	# to the : no-op command also slightly speeds it up, because field splitting and
	# pathname expansion are not performed.) This modernish version, like pdksh/mksh and
	# Busybox ash, does not accept the '--' end-of-options delimiter.
	# (Using 'eval' to avoid syntax error in case an alias let='let --' was set above.)
	eval 'let() {
		case $# in
		( 1 )	return "$((!($1)))" ;;
		( 2 )	: "$(($1))"
			return "$((!($2)))" ;;
		( 3 )	: "$(($1))$(($2))"
			return "$((!($3)))" ;;
		( 4 )	: "$(($1))$(($2))$(($3))"
			return "$((!($4)))" ;;
		( 5 )	: "$(($1))$(($2))$(($3))$(($4))"
			return "$((!($5)))" ;;
		( 6 )	: "$(($1))$(($2))$(($3))$(($4))$(($5))"
			return "$((!($6)))" ;;
		( 7 )	: "$(($1))$(($2))$(($3))$(($4))$(($5))$(($6))"
			return "$((!($7)))" ;;
		( 8 )	: "$(($1))$(($2))$(($3))$(($4))$(($5))$(($6))$(($7))"
			return "$((!($8)))" ;;
		( 0 )	die "let: expression expected" || return ;;
		( * )	: "$(($1))$(($2))$(($3))$(($4))$(($5))$(($6))$(($7))$(($8))"
			shift 8
			let "$@" ;;
		esac
	}' ;;
esac

# Test if the given argument is a valid integer number in shell syntax. Decimal
# /[+-]*[0-9]+/, octal /[+-]0[0-7]*/ and hexadecimal /[+-]0[xX][0-9a-fA-F]+/
# are supported. For peformance, express these extended regular expressions in
# rather convoluted glob patterns for 'case'.
# Tolerate only leading and not trailing whitespace; most shells
# tolerate both in arithmetic expansion, but yash and FreeBSD /bin/sh only
# tolerate leading whitespace in values expanded from variables, so use the
# most restrictive/compatible check. (Quirk ID: QRK_ARITHWHSP)
# Discussion: https://osdn.jp/ticket/browse.php?group_id=3863&tid=36002
# See also strtol(3) and wcstol(3) which tolerate only leading whitespace.
# http://pubs.opengroup.org/onlinepubs/9699919799/functions/strtol.html
# http://pubs.opengroup.org/onlinepubs/9699919799/functions/wcstol.html
isint() {
	case $# in
	( 1 )	case ${1#"${1%%[!" $CCt$CCn"]*}"} in								# "
		( 0[xX]*[!0123456789abcdefABCDEF]* | [+-]0[xX]*[!0123456789abcdefABCDEF]* )
			return 1 ;;
		( 0[xX]?* | [+-]0[xX]?* )
			;;
		( '' | [+-] | ?*[+-]* | *[!0123456789+-]* | 0*[!01234567]* | [+-]0*[!01234567]* )
			return 1 ;;
		esac ;;
	( 0 )	return 1 ;;
	( * )	_Msh_dieArgs isint "$#" '0 or 1' || return ;;
	esac
}

# ---- String tests. ----
# (Negative string tests are not provided; just put 'not' or '!' before them)

# Test for the empty string. Usage: empty <value>
#	Unlike "test -z", this function deals correctly with the POSIX
#	shell's non-optional removal of unquoted empty arguments: it accepts
#	zero arguments as equivalent to empty. That means, if you 'use safe',
#	you can do 'if empty $var' without having to quote $var, because
#	field splitting or globbing are turned off.
#	The function treats more than one argument as a fatal error, because
#	that is a sign of unexpected field splitting or globbing.
empty() {
	case ${#}${1:+n} in
	( 0 | 1 ) ;;
	( 1n ) return 1 ;;
	( * ) _Msh_dieArgs empty "$#" '0 or 1' ;;
	esac
}

# Test for identical strings. Usage: identic <value1> <value2>
#	This function deals correctly with the POSIX shell's non-optional
#	removal of unquoted empty arguments: it accepts zero arguments as
#	equivalent to "identical" (i.e. two removed empties) and one
#	argument as "not identical" (one removed empty, one non-empty).
#	That means, if you 'use safe', you can do 'if identic $var1 $var2'
#	without having to quote $var1 and $var2, provided field splitting or
#	globbing are not turned on.
#	The function treats more than two arguments as a fatal error,
#	because that is a sign of unexpected field splitting or globbing.
identic() {
	case ${#},${1-} in
	( [01], | 2,"${2-}" ) ;;
	( [12],* ) return 1 ;;
	( * ) _Msh_dieArgs identic "$#" 'max. 2' ;;
	esac
}

# String comparison tests:
# Usage: <contains|startswith|endswith> <string> <string>
# Return successfully if the first string contains, starts with or ends with the
# second string, unsuccessfully otherwise.
# Empty removal handling: if one argument is omitted, assume the first was a
# removed unquoted empty parameter and return false. 0 arguments = fatal error.
contains() {
	case ${#},${1-} in
	( 2,*"${2-}"* )	;;
	( [12],* )	return 1 ;;
	( * )		_Msh_dieArgs contains "$#" '2 or 1' ;;
	esac
}
startswith() {
	case ${#},${1-} in
	( 2,"${2-}"* )	;;
	( [12],* )	return 1 ;;
	( * )		_Msh_dieArgs startswith "$#" '2 or 1' ;;
	esac
}
endswith() {
	case ${#},${1-} in
	( 2,*"${2-}" )	;;
	( [12],* )	return 1 ;;
	( * )		_Msh_dieArgs endswith "$#" '2 or 1' ;;
	esac
}

# Glob pattern test.
# Usage: match <string> <glob-pattern>
#
# Unfortunately, many shells don't properly support passing a glob pattern
# with backslash-escaped characters from a variable. But the behaviour with
# patterns as string literals is the same on all shells. To ensure
# portability, we must use 'eval' to parse patterns containing backslashes
# as string literals. This involves backslash-quoting the pattern in a
# special way to make it safe for 'eval' while preserving already-quoted
# characters and avoiding quoting glob pattern characters '?', '*' and '['.
#	With this method, the only portability issue left is a final single
# backslash in the pattern. Shells vary. POSIX says: "If a pattern ends with
# an unescaped <backslash>, it is unspecified whether the pattern does not
# match anything or the pattern is treated as invalid." In fact, some shells
# do neither and match it as if it were an escaped backslash. To ensure the
# same behaviour on all shells, specifically check for a dangling final
# backslash and treat it as invalid by returning exit status 2.
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_13_01
#
# When matching single characters, beware of BUG_MULTIBYTE!
#
# Empty removal handling: if one argument is omitted, assume the first was a
# removed unquoted empty parameter and return false. 0 arguments = fatal error.
#
# Note: conflicts with external 'match' command from the Mail Avenger package.
# Use 'extern match' to use an external 'match' command.
#
# Preliminary test version:
match() {
	case $1 in
	( $2 ) ;;
	( * ) return 1 ;;
	esac
}
# Check if the shell can reliably pass backslash-escaped characters from a parameter.
# (bash has some mysterious trouble with backslash-escaped $CC01 specifically.)
if ! match '? *x'${CC01}y '??\*\x\'${CC01}'\y'; then
	# Shell does not support passing backslash-escaped characters from a variable. Need to parse
	# patterns containing backslashes as string literals, which requires making the pattern
	# string safe for 'eval'. Only bother with this if the pattern in fact contains a backslash.
	if thisshellhas BUG_CASECC01; then
		_Msh_BUG_CASECC01='# BUG_CASECC01 compat: handle ^A specially.
				($CC01*) _Msh_Q=${_Msh_Q}\${CC01}
					_Msh_P=${_Msh_P#?} ;;
				(\\$CC01*) _Msh_Q=${_Msh_Q}\${CC01}
					_Msh_P=${_Msh_P#??} ;;'
	else
		_Msh_BUG_CASECC01=''
	fi
	_Msh_match_backslash='( 2,*\\* )
			_Msh_Q=
			_Msh_P=$2
			while :; do
				case ${_Msh_P} in
				( "" )	break ;;
				# Handle newline specially with a ref to $CCn.
				($CCn*)	_Msh_Q=${_Msh_Q}\${CCn}
					_Msh_P=${_Msh_P#?} ;;
				# Handle backslash-escaped newline specially with a ref to $CCn.
				(\\$CCn*)_Msh_Q=${_Msh_Q}\${CCn}
					_Msh_P=${_Msh_P#??} ;;
				'"${_Msh_BUG_CASECC01}"'
				# Leave other backslash-escaped characters alone.
				(\\?*)	_Msh_Q=${_Msh_Q}${_Msh_P%"${_Msh_P#??}"}
					_Msh_P=${_Msh_P#??} ;;
				# Leave unescaped glob characters and shell-safe characters alone.
				([][?*]* | ["$SHELLSAFECHARS"]*)
					_Msh_Q=${_Msh_Q}${_Msh_P%"${_Msh_P#?}"}
					_Msh_P=${_Msh_P#?} ;;
				# Backslash-escape everything else.
				( * )	_Msh_Q=${_Msh_Q}\\${_Msh_P%"${_Msh_P#?}"}
					_Msh_P=${_Msh_P#?} ;;
				esac
			done
			eval "unset -v _Msh_P _Msh_Q
				case \$1 in
				( ${_Msh_Q} )
					;;
				( * )	return 1 ;;
				esac" ;;'
	unset -v _Msh_BUG_CASECC01
fi
# Set the function, inserting workarounds if and where appropriate.
eval 'match() {
	case ${#},${2-} in
	( 2,\\ | 2,*[!\\]\\ )
		return 2 ;;	# dangling final backslash
	'"${_Msh_match_backslash}"'
	( 2,* )	case $1 in
		( $2 ) ;;
		( * ) return 1 ;;
		esac ;;
	( 1,* )	return 1 ;;
	( * )	_Msh_dieArgs match "$#" "2 or 1" ;;
	esac
}'
unset -v _Msh_match_backslash

# Extended regular expression test.
# Usage: ematch <string> <extended-regex>
#
# Use the [[ keyword (or '[' on yash) if available and if it supports
# extended regular expressions. This is much faster than the standard method
# which involves invoking the external grep command.
#
# Empty removal handling: if one argument is omitted, assume the first was a
# removed unquoted empty parameter and return false. 0 arguments = fatal error.
if thisshellhas --rw=[[ && ( eval "[[ aaa =~ ^a{2,}$ ]]" ) 2>/dev/null; then
	# Wrap the function definition in 'eval', otherwise shells that
	# have '[[' but don't support '=~' fail to parse the script.
	eval 'ematch() {
		case $# in
		( 2 )	[[ $1 =~ $2 ]] ;;
		( 1 )	return 1 ;;
		( * )	_Msh_dieArgs ematch "$#" "2 or 1" ;;
		esac
	}'
elif thisshellhas --bi=test && ( PATH=$DEFPATH command test aaa '=~' '^a{2,}$' ) 2>/dev/null; then
	# yash and zsh support extended regex matching in builtin test/[
	# (the test needs subshell on zsh in case its regex module fails to load)
	ematch() {
		case $# in
		( 2 )	test "$1" '=~' "$2" ;;
		( 1 )	return 1 ;;
		( * )	_Msh_dieArgs ematch "$#" '2 or 1' ;;
		esac
	}
else
	# Default/POSIX: use awk's match().
	ematch() {
		case $# in
		( 2 )	PATH=$DEFPATH POSIXLY_CORRECT=y _Msh_V=$1 _Msh_R=$2 command awk \
				'BEGIN { exit(!match(ENVIRON["_Msh_V"],ENVIRON["_Msh_R"])); }' \
				|| { let "$? > 1" && die "ematch: 'awk' failed"; } ;;
		( 1 )	return 1 ;;
		( * )	_Msh_dieArgs ematch "$#" '2 or 1' ;;
		esac
	}
fi

# --- General file tests. ---
# The can() and is() functions deal correctly with empty removal so are good
# to use with 'use safe' and unquoted variables. They also use substantially
# different and more intuitive logic than 'test', '[' and '[[' do; see below.
# can():
#	--- permsision tests ---
#	can read, can write:
#		Test if this program can read from or write to a file or
#		directory. Work around botched '['/'[[' logic that claims
#		you can (-r)ead from or (-w)rite to a directory even if its
#		"x" bit is not set. (-d && ( -[rw] && -x ) || -[rw])
#	can exec
#		Test if non-directory file is executable. (-x && ! -d)
#	can traverse:
#		Test if you can traverse through a directory. (-x && -d)
#		Distinct from 'can exec' to help avoid bugs.
# is():
#	--- ownership tests ---
#	is ssetuid, is setgid:
#		Test if file has user or group ID bits set.
#	is mine, is mygroup:
#		Test if file is owned by user or by current user's main
#		group. (Note: the -O and -G test/[ operators are technically
#		non-standard, but their support in shells that can run the
#		rest of modernish is universal.)
#	--- type tests ---
#	is reg, is dir, is fifo, is socket, is blockspecial, is charspecial:
#		Test if file is a regular file, directory, socket, block
#		special device or character special device, respectively.
#		NOTE: Unlike [/[[, these tests do *not* resolve symlinks
#		unless the -L option is used! This is to promote security
#		and discourage allowing symlink attacks.
#	is -L reg, is -L dir, is -L fifo, etc.
#		Same as above but resolve symlinks before testing. For
#		example, 'is -L reg file.txt' could mean file.txt is a
#		regular file or a symlink to a regular file.
#	is sym:
#		Test if file is a symlink.
#	is -L sym:
#		Test if file is a valid symlink.
#	is present:
#		Test if file exists (even if it's an invalid symlink).
#	is -L present:
#		Test if file exists and is not an invalid symlink.
#	--- content test ---
#	is nonempty:
#		Test if file exists, is not an invalid symlink, and is non-empty. Unlike 'test -s',
#		this also works for directories in which you have read permission (both r and x
#		bits set). A race condition with tests like this is inevitable (even with the
#		traditional 'test -s'). Be careful with parallel processing!
#		Exit status:
#		0: file or directory (after resolving any symlinks) is not empty
#		1: file or directory is empty, doesn't exist, or is an invalid symlink
#		2: no read permission in directory, so cannot test if directory is empty
#		The directory testing method was kindly provided by Stéphane Chazelas in:
#		Message-ID: <20150524190928.GB6744@chaz.gmail.com>
#		https://groups.google.com/forum/#!original/comp.unix.shell/M_gDU9uk8Rk/FyiS9m-RFYAJ
#		BUG: reads entire directory; slow/expensive for very large directories.
#	--- file descriptor test ---
#	is onterminal:
#		Test if file descriptor is open and associated with a terminal.
#		(Note: POSIX specifies that file descriptors can be 0 to minimum 19,
#		but most shells only support file descriptors between 0 and 9.)
#	--- comparison tests (2 arguments) ---
#	is newer, is older, is samefile:
#		Test if file 1 is newer than, older than, or (through hard
#		links or symlinks) the same file as file 2. (Note: the -nt,
#		-ot and -ef test/[ operators are technically non-standard, but
#		their support in shells that can run the rest of modernish is
#		universal.)

if thisshellhas --rw=[[; then
	# Use [[ if available because it's generally faster and more robust;
	# this also avoids BUG_TESTPAREN in zsh 5.0.6/5.0.7 which makes it
	# impossible for test/[ to check for files named '(', ')' or '!'.
	[[ / -nt /dev/null/nonexistent ]] && _Msh_test= || _Msh_test=y	# for is newer/is older
	eval 'can() {
		case $# in
		( 1 )	case $1 in
			( read | write | exec | traverse )
				# removed empty argument: return false
				return 1 ;;
			( * )	die "can: invalid operator: $1" ;;
			esac ;;
		( 2 )	case $1 in
			( read )
				[[ -d $2 && ( -r $2 && -x $2 ) || -r $2 ]] ;;
			( write )
				[[ -d $2 && ( -w $2 && -x $2 ) || -w $2 ]] ;;
			( exec )
				[[ -x $2 && -f $2 ]] ;;
			( traverse )
				[[ -x $2 && -d $2 ]] ;;
			( * )	die "can: invalid operator: $1" ;;
			esac ;;
		( * )	_Msh_dieArgs can "$#" "1 or 2" ;;
		esac
	}
	is() {
		case $# in
		( 1 )	case $1 in
			( present | reg | dir | sym | fifo | socket | blockspecial | charspecial \
			| nonempty | setuid | setgid | mine | mygroup )
				# removed empty argument: return false
				return 1 ;;
			( * )	die "is: invalid operator: $1" ;;
			esac ;;
		( 2 )	case $1 in
			( present )
				[[ -e $2 || -L $2 ]] ;;
			( reg )	[[ ! -L $2 && -f $2 ]] ;;
			( dir )	[[ ! -L $2 && -d $2 ]] ;;
			( sym )	[[ -L $2 ]] ;;
			( fifo )
				[[ ! -L $2 && -p $2 ]] ;;
			( socket )
				[[ ! -L $2 && -S $2 ]] ;;
			( blockspecial )
				[[ ! -L $2 && -b $2 ]] ;;
			( charspecial )
				[[ ! -L $2 && -c $2 ]] ;;
			( nonempty )
				if [[ -d $2 ]]; then
					[[ -r $2 && -x $2 ]] || return 2
					case $- in
					( *f* ) set +f
						set -- "${2%/}" "${2%/}"/[*] "${2%/}"/* "${2%/}"/.[!.]* "${2%/}"/.??*
						set -f ;;
					( * )	set -- "${2%/}" "${2%/}"/[*] "${2%/}"/* "${2%/}"/.[!.]* "${2%/}"/.??* ;;
					esac
					[[ "${#} $2 $3 $4 $5" != "5 $1/[*] $1/* $1/.[!.]* $1/.??*" ]]
				else
					[[ -s $2 ]]
				fi ;;
			( setuid )
				[[ -u $2 ]] ;;
			( setgid )
				[[ -g $2 ]] ;;
			( mine )
				[[ -O $2 ]] ;;
			( mygroup )
				[[ -G $2 ]] ;;
			( onterminal )
				case $2 in
				( *[!0123456789]* )
					die "is onterminal: invalid file descriptor: $2" ;;
				( * )	[[ -t $2 ]] ;;
				esac ;;
			( -L )	case $2 in
				( present | reg | dir | sym | fifo | socket | blockspecial | charspecial )
					# removed empty argument: return false
					return 1 ;;
				( * )	die "is -L: invalid operator: $2" ;;
				esac ;;
			( * )	die "is: invalid operator: $2" ;;
			esac ;;
		( 3 )	case $1 in
			( -L )	case $2 in
				( present )
					[[ -e $3 ]] ;;
				( reg )	[[ -f $3 ]] ;;
				( dir )	[[ -d $3 ]] ;;
				( sym )	[[ -L $3 && -e $3 ]] ;;	# "is -L sym": test if valid symlink.
				( fifo )
					[[ -p $3 ]] ;;
				( socket )
					[[ -S $3 ]] ;;
				( blockspecial )
					[[ -b $3 ]] ;;
				( charspecial )
					[[ -c $3 ]] ;;
				( * )	die "is -L: invalid operator: $2" ;;
				esac ;;
			( newer )
				if [[ -L "$2" || -L "$3" ]]; then
					case $(PATH=$DEFPATH POSIXLY_CORRECT=y command ls -td -- "$2" "$3" 2>/dev/null
						put X) in
					( "${2}${CCn}${3}${CCn}X" | "${2}${CCn}X" ) ;;
					( "${3}${CCn}${2}${CCn}X" | "${3}${CCn}X" ) return 1 ;;
					( * )	die "is newer: internal error: invalid '\''ls'\'' output" ;;
					esac
				else
					[[ $2 -nt $3'${_Msh_test:+' || ( -e $2 && ! -e $3 )'}' ]]
				fi ;;
			( older )
				if [[ -L "$2" || -L "$3" ]]; then
					case $(PATH=$DEFPATH POSIXLY_CORRECT=y command ls -td -- "$2" "$3" 2>/dev/null
						put X) in
					( "${3}${CCn}${2}${CCn}X" | "${3}${CCn}X" ) ;;
					( "${2}${CCn}${3}${CCn}X" | "${2}${CCn}X" ) return 1 ;;
					( * )	die "is older: internal error: invalid '\''ls'\'' output" ;;
					esac
				else
					[[ $2 -ot $3'${_Msh_test:+' || ( -e $3 && ! -e $2 )'}' ]]
				fi ;;
			( samefile )
				[[ -L "$2" ]] && set -- "$1" "$2" "$3" "A"
				[[ -L "$3" ]] && set -- "$1" "$2" "$3" "${4-}B"
				case ${4-} in
				( AB )	# Check if two symlinks are hardlinks of each other, which "test A -ef B" does not allow.
					set -- "$(unset -f ls	# QRK_EXECFNBI compat
						LC_ALL=C POSIXLY_CORRECT=y PATH=$DEFPATH exec ls -id -- "$2" 2>/dev/null)" "$2" "$3"
					set -- "${1%%["$WHITESPACE"]*}" "$2" "$3"
					case $(unset -f ls	# QRK_EXECFNBI compat
						LC_ALL=C POSIXLY_CORRECT=y PATH=$DEFPATH exec ls -id -- "$3" 2>/dev/null) in
					( "$1"["$WHITESPACE"]* )
						;;
					( * )	return 1 ;;
					esac ;;
				( "" )	[[ $2 -ef $3 ]] ;;
				( * )	return 1 ;;
				esac ;;
			( onsamefs )
				# Make sure we have path names so we can strip the last element.
				[[ $2 != */* ]] && set -- "$1" "$PWD/$2" "$3"
				[[ $3 != */* ]] && set -- "$1" "$2" "$PWD/$3"
				# Return false if either of the items does not exist.
				[[ -e $2 || -L $2 ]] || return
				[[ -e $3 || -L $3 ]] || return
				# Strip any non-regular, non-directory files from the paths.
				[[ -L $2 || (! -f $2 && ! -d $2) ]] && set -- "$1" "${2%/*}" "$3"
				[[ -L $3 || (! -f $3 && ! -d $3) ]] && set -- "$1" "$2" "${3%/*}"
				# Do the test if the stripped paths are different.
				[[ ${2:-/} == "${3:-/}" ]] || _Msh_doIsOnSameFs "${2:-/}" "${3:-/}" ;;
			( * )	die "is: invalid arguments" ;;
			esac ;;
		( 4 )	case $1 in
			( -L )	case $2 in
				( newer )
					[[ $3 -nt $4'${_Msh_test:+' || ( -e $3 && ! -e $4 )'}' ]] ;;
				( older )
					[[ $3 -ot $4'${_Msh_test:+' || ( -e $4 && ! -e $3 )'}' ]] ;;
				( samefile )
					[[ $3 -ef $4 ]] ;;
				( onsamefs )
					# Make sure we have path names so we can strip the last element.
					[[ $3 != */* ]] && set -- "$1" "$2" "$PWD/$3" "$4"
					[[ $4 != */* ]] && set -- "$1" "$2" "$3" "$PWD/$4"
					# Return false if either of the items does not exist.
					[[ -e $3 || -L $3 ]] || return
					[[ -e $4 || -L $4 ]] || return
					# If we have a valid symlink to a non-regular, non-directory file, substitute the
					# target of the link before stripping its final element to keep "df -P" happy.
					if [[ -L $3 && -e $3 && ! -d $3 && ! -f $3 ]]; then
						set -- "$1" "$2" "$(POSIXLY_CORRECT=y PATH=$DEFPATH command ls -ld -- "$3"
							put X)" "$4" "$3"
						set -- "$1" "$2" "${3%${CCn}X}" "$4" "$5"
						set -- "$1" "$2" "${3#*" $5 -> "}" "$4"
					fi
					if [[ -L $4 && -e $3 && ! -d $4 && ! -f $4 ]]; then
						set -- "$1" "$2" "$3" "$(POSIXLY_CORRECT=y PATH=$DEFPATH command ls -ld -- "$4"
							put X)" "$4"
						set -- "$1" "$2" "$3" "${4%${CCn}X}" "$5"
						set -- "$1" "$2" "$3" "${4#*" $5 -> "}"
					fi
					# Strip any invalid symlinks or non-regular, non-directory files from the paths.
					[[ ! -e $3 || (! -f $3 && ! -d $3) ]] && set -- "$1" "$2" "${3%/*}" "$4"
					[[ ! -e $4 || (! -f $4 && ! -d $4) ]] && set -- "$1" "$2" "$3" "${4%/*}"
					# Do the test if the paths are different.
					[[ ${3:-/} == "${4:-/}" ]] || _Msh_doIsOnSameFs "${3:-/}" "${4:-/}" ;;
				( * )	die "is -L: invalid operator: $3" || return ;;
				esac ;;
			( * )	die "is: invalid arguments" || return ;;
			esac ;;
		( * )	_Msh_dieArgs is "$#" "1 or 2" ;;
		esac
	}'
else
	# Note: 'test' was hardened against failure above using a shell function.
	test / -nt /dev/null/nonexistent && _Msh_test= || _Msh_test=y	# for is newer/is older
	eval 'can() {
		case $# in
		( 1 )	case $1 in
			( read | write | exec | traverse )
				# removed empty argument: return false
				return 1 ;;
			( * )	die "can: invalid operator: $1" ;;
			esac ;;
		( 2 )	case $1 in
			( read )
				if	test -d "$2"
				then	test -r "$2" && test -x "$2"
				else	test -r "$2"
				fi ;;
			( write )
				if	test -d "$2"
				then	test -w "$2" && test -x "$2"
				else	test -w "$2"
				fi ;;
			( exec )
				test -x "$2" && test -f "$2" ;;
			( traverse )
				test -x "$2" && test -d "$2" ;;
			( * )	die "can: invalid operator: $1" || return ;;
			esac ;;
		( * )	_Msh_dieArgs can "$#" "1 or 2" ;;
		esac
	}
	is() {
		case $# in
		( 1 )	case $1 in
			( present | reg | dir | sym | fifo | socket | blockspecial | charspecial \
			| setuid | setgid | mine | mygroup )
				# removed empty argument: return false
				return 1 ;;
			( * )	die "is: invalid operator: $1" || return ;;
			esac ;;
		( 2 )	case $1 in
			( present )
				test -e "$2" || test -L "$2" ;;
			( reg )	! test -L "$2" && test -f "$2" ;;
			( dir )	! test -L "$2" && test -d "$2" ;;
			( sym )	test -L "$2" ;;
			( fifo )
				! test -L "$2" && test -p "$2" ;;
			( socket )
				! test -L "$2" && test -S "$2" ;;
			( blockspecial )
				! test -L "$2" && test -b "$2" ;;
			( charspecial )
				! test -L "$2" && test -c "$2" ;;
			( nonempty )
				if test -d "$2"; then
					test -r "$2" && test -x "$2" || return 2
					case $- in
					( *f* ) set +f
						set -- "${2%/}" "${2%/}"/[*] "${2%/}"/* "${2%/}"/.[!.]* "${2%/}"/.??*
						set -f ;;
					( * )	set -- "${2%/}" "${2%/}"/[*] "${2%/}"/* "${2%/}"/.[!.]* "${2%/}"/.??* ;;
					esac
					case "${#} $2 $3 $4 $5" in
					( "5 $1/[*] $1/* $1/.[!.]* $1/.??*" )
						return 1 ;;
					esac
				else
					test -s "$2"
				fi ;;
			( setuid )
				test -u "$2" ;;
			( setgid )
				test -g "$2" ;;
			# (The -O and -G test/[ operators are technically
			# non-standard, but their support in shells that can
			# run the rest of modernish is universal.)
			( mine )
				test -O "$2" ;;
			( mygroup )
				test -G "$2" ;;
			( onterminal )
				case $2 in
				( *[!0123456789]* )
					die "is onterminal: invalid file descriptor: $2" || return ;;
				( * )	test -t "$2" ;;
				esac ;;
			( -L )	case $2 in
				( present | reg | dir | sym | fifo | socket | blockspecial | charspecial )
					# removed empty argument: return false
					return 1 ;;
				( * )	die "is -L: invalid operator: $2" || return ;;
				esac ;;
			( * )	die "is: invalid operator: $1" || return ;;
			esac ;;
		( 3 )	case $1 in
			( -L )	case $2 in
				( present )
					test -e "$3" ;;
				( reg )	test -f "$3" ;;
				( dir )	test -d "$3" ;;
				( sym )	test -L "$3" && test -e "$3" ;;	# "is -L sym": test if valid symlink.
				( fifo )
					test -p "$3" ;;
				( socket )
					test -S "$3" ;;
				( blockspecial )
					test -b "$3" ;;
				( charspecial )
					test -c "$3" ;;
				( * )	die "is -L: invalid operator: $2" || return ;;
				esac ;;
			# (The -nt, -ot and -ef test/[ operators are
			# technically non-standard, but their support in shells
			# that can run the rest of modernish is universal.)
			( newer )
				if test -L "$2" || test -L "$3"; then
					case $(PATH=$DEFPATH POSIXLY_CORRECT=y command ls -td -- "$2" "$3" 2>/dev/null
						put X) in
					( "${2}${CCn}${3}${CCn}X" | "${2}${CCn}X" ) ;;
					( "${3}${CCn}${2}${CCn}X" | "${3}${CCn}X" ) return 1 ;;
					( * )	die "is newer: internal error: invalid '\''ls'\'' output" ;;
					esac
				else
					test "$2" -nt "$3"'${_Msh_test:+' || { test -e "$2" && ! test -e "$3"; '\}}'
				fi ;;
			( older )
				if test -L "$2" || test -L "$3"; then
					case $(PATH=$DEFPATH POSIXLY_CORRECT=y command ls -td -- "$2" "$3" 2>/dev/null
						put X) in
					( "${3}${CCn}${2}${CCn}X" | "${3}${CCn}X" ) ;;
					( "${2}${CCn}${3}${CCn}X" | "${2}${CCn}X" ) return 1 ;;
					( * )	die "is older: internal error: invalid '\''ls'\'' output" ;;
					esac
				else
					test "$2" -ot "$3"'${_Msh_test:+' || { test -e "$3" && ! test -e "$2"; '\}}'
				fi ;;
			( samefile )
				test -L "$2" && set -- "$1" "$2" "$3" "A"
				test -L "$3" && set -- "$1" "$2" "$3" "${4-}B"
				case ${4-} in
				( AB )	# Check if two symlinks are hardlinks of each other, which "test A -ef B" does not allow.
					set -- "$(unset -f ls	# QRK_EXECFNBI compat
						LC_ALL=C POSIXLY_CORRECT=y PATH=$DEFPATH exec ls -id -- "$2" 2>/dev/null)" "$2" "$3"
					set -- "${1%%["$WHITESPACE"]*}" "$2" "$3"
					case $(unset -f ls	# QRK_EXECFNBI compat
						LC_ALL=C POSIXLY_CORRECT=y PATH=$DEFPATH exec ls -id -- "$3" 2>/dev/null) in
					( "$1"["$WHITESPACE"]* )
						;;
					( * )	return 1 ;;
					esac ;;
				( "" )	test "$2" -ef "$3" ;;
				( * )	return 1 ;;
				esac ;;
			( onsamefs )
				# Make sure we have path names so we can strip the last element.
				case $2 in (*/*) ;; (*) set -- "$1" "$PWD/$2" "$3" ;; esac
				case $3 in (*/*) ;; (*) set -- "$1" "$2" "$PWD/$3" ;; esac
				# Return false if either of the items does not exist.
				test -e "$2" || test -L "$2" || return
				test -e "$3" || test -L "$3" || return
				# Strip any non-regular, non-directory files from the paths.
				{ test -L "$2" || { ! test -f "$2" && ! test -d "$2"; }; } && set -- "$1" "${2%/*}" "$3"
				{ test -L "$3" || { ! test -f "$3" && ! test -d "$3"; }; } && set -- "$1" "$2" "${3%/*}"
				# Do the test if the stripped paths are different.
				case ${2:-/} in ("${3:-/}") ;; ( * ) _Msh_doIsOnSameFs "${2:-/}" "${3:-/}" ;; esac ;;
			( * )	die "is: invalid arguments" || return ;;
			esac ;;
		( 4 )	case $1 in
			( -L )	case $2 in
				( newer )
					test "$3" -nt "$4"'${_Msh_test:+' || { test -e "$3" && ! test -e "$4"; '\}}' ;;
				( older )
					test "$3" -ot "$4"'${_Msh_test:+' || { test -e "$4" && ! test -e "$3"; '\}}' ;;
				( samefile )
					test "$3" -ef "$4" ;;
				( onsamefs )
					# Make sure we have path names so we can strip the last element.
					case $3 in (*/*) ;; (*) set -- "$1" "$2" "$PWD/$3" "$4" ;; esac
					case $4 in (*/*) ;; (*) set -- "$1" "$2" "$3" "$PWD/$4" ;; esac
					# Return false if either of the items does not exist.
					test -e "$3" || test -L "$3" || return
					test -e "$4" || test -L "$4" || return
					# If we have a valid symlink to a non-regular, non-directory file, substitute the
					# target of the link before stripping its final element to keep "df -P" happy.
					if test -L "$3" && test -e "$3" && ! test -d "$3" && ! test -f "$3"; then
						set -- "$1" "$2" "$(POSIXLY_CORRECT=y PATH=$DEFPATH command ls -ld -- "$3"
							put X)" "$4" "$3"
						set -- "$1" "$2" "${3%${CCn}X}" "$4" "$5"
						set -- "$1" "$2" "${3#*" $5 -> "}" "$4"
					fi
					if test -L "$4" && test -e "$3" && ! test -d "$4" && ! test -f "$4"; then
						set -- "$1" "$2" "$3" "$(POSIXLY_CORRECT=y PATH=$DEFPATH command ls -ld -- "$4"
							put X)" "$4"
						set -- "$1" "$2" "$3" "${4%${CCn}X}" "$5"
						set -- "$1" "$2" "$3" "${4#*" $5 -> "}"
					fi
					# Strip any invalid symlinks or non-regular, non-directory files from the paths.
					{ ! test -e "$3"||{ ! test -f "$3"&&! test -d "$3";};} && set -- "$1" "$2" "${3%/*}" "$4"
					{ ! test -e "$4"||{ ! test -f "$4"&&! test -d "$4";};} && set -- "$1" "$2" "$3" "${4%/*}"
					# Do the test if the stripped paths are different.
					case ${3:-/} in ("${4:-/}") ;; ( * ) _Msh_doIsOnSameFs "${3:-/}" "${4:-/}" ;; esac ;;
				( * )	die "is -L: invalid operator: $3" || return ;;
				esac ;;
			( * )	die "is: invalid arguments" || return ;;
			esac ;;
		( * )	_Msh_dieArgs is "$#" "1 or 2" || return ;;
		esac
	}'
fi
_Msh_doIsOnSameFs() {
	# Invoke POSIX "df -P" and isolate the file system names and mount points as reliably as possible.
	# Ref. (thread): https://www.mail-archive.com/austin-group-l@opengroup.org/msg01699.html
	_Msh_is=$(export POSIXLY_CORRECT=y "PATH=$DEFPATH"
		unset -f df sed  # QRK_EXECFNBI compat
		exec df -P -- "$1" "$2" | exec sed '1d; s/\([[:blank:]]\{1,\}[[:digit:]]\{1,\}\)\{4\}%[[:blank:]]\{1,\}/,/')
	# If the two lines are identical, the files are on the same filesystem.
	case ${_Msh_is#*$CCn} in
	( *$CCn* | "${_Msh_is}" )  # >2 lines or 1 line
		die "is onsamefs: internal error" || return ;;
	( "${_Msh_is%$CCn*}" )
		unset -v _Msh_is ;;
	( * )	! unset -v _Msh_is ;;
	esac
}

# -------------

# For thisshellhas(): Now that we have is(), we can replace the preliminary
# _Msh_doCapTest() with a more straightforward and robust one.
_Msh_doCapTest() {
	unset -v _Msh_test						# guarantee unset variable for testing purposes
	set -- "$MSH_PREFIX/libexec/modernish/cap/$1.t"			# this can be used by test scripts as well
	is -L reg "$1" || return 127
	. "$1" 1>&2
}

# -------------

# ---- Basic string manipulation commands. ----
# (Use var/string for more)

# toupper and tolower: convert one or more variable's content to upper- and lowercase letters, respectively.
# Usage:	toupper [ <varname> [ <varname> ... ] ]
#		tolower [ <varname> [ <varname> ... ] ]
# If the <varname> argument is omitted, they copy standard input to standard output, converting case.
# NOTE: Some shells or external 'tr' commands cannot convert UTF-8 or other non-ASCII characters to upper
# or lower case. Modernish tries hard to make one or the other work, but sometimes neither the shell nor
# 'tr' can handle it. This is tested for as BUG_CNONASCII (see libexec/modernish/cap/BUG_CNONASCII.t). Be
# sure to check if 'thisshellhas BUG_CNONASCII' if you need to rely on converting non-ASCII characters.

# Determine function definition method.
if thisshellhas KSH93FUNC; then
	# On AT&T ksh93, we *must* define the functions with the 'function' keyword
	# so that 'typeset' makes the temp variable local to the function as expected.
	_Msh_toupper_fn='function toupper'
	_Msh_tolower_fn='function tolower'
else
	_Msh_toupper_fn='toupper()'
	_Msh_tolower_fn='tolower()'
fi

# Based on available shell features, generate code for the 'eval' within the functions, which are
# themselves 'eval'ed because their code depends on a complex interplay of shell features. So we are
# dealing with two levels of 'eval' below. The specified variable name is always in ${1}.

# First, the default 'tr' commands.
# These may also be needed as a fallback for the 'typeset' method, so use a shell function to init them on demand.
# If we're in a UTF-8 locale, it's very hit-and-miss which command can convert case correctly; modernish will try
# 'tr', 'awk', GNU 'awk' and GNU 'sed' before giving up (and detecting BUG_CNONASCII).
# Basic form is:
#	var=$(put "${var}X" | LC_ALL=(locale) awk '[:lower:]' '[:upper:]') || die "'tr' failed"; var=${var%?}
# ... making sure that LC_ALL is exported to 'tr' with the value of the shell's current locale, and defeating
# command substitution's stripping of final linefeeds by adding a protector character and removing it afterwards.
_Msh_tmp_getWorkingTr() {
	_Msh_a1='${1}=\$(putln \"\${${1}}X\" | '
	_Msh_a2=' failed\"; ${1}=\${${1}%?}'

	# Default: use 'tr'.
	# ... for handling a variable name (within 'eval'):
	_Msh_tr1="${_Msh_a1}PATH=\\\$DEFPATH command tr "
	_Msh_tr2=": 'tr'${_Msh_a2}"
	_Msh_toupper_tr="${_Msh_tr1}'[:lower:]' '[:upper:]') || die \\\"toupper${_Msh_tr2}"
	_Msh_tolower_tr="${_Msh_tr1}'[:upper:]' '[:lower:]') || die \\\"tolower${_Msh_tr2}"
	# ... for converting standard input (without 'eval'):
	_Msh_toupper_TR="PATH=\$DEFPATH command tr '[:lower:]' '[:upper:]' || die \"toupper: 'tr' failed\""
	_Msh_tolower_TR="PATH=\$DEFPATH command tr '[:upper:]' '[:lower:]' || die \"tolower: 'tr' failed\""

	case ${LC_ALL:-${LC_CTYPE:-${LANG:-}}} in
	( *[Uu][Tt][Ff]8* | *[Uu][Tt][Ff]-8* )
		# We're in a UTF-8 locale in 2017. Yet, finding a command that will correctly convert case is a challenge.
		_Msh_test=$(putln 'mĳn δéjà_вю' | PATH=$DEFPATH exec tr '[:lower:]' '[:upper:]')
		case ${_Msh_test} in
		( 'MĲN ΔÉJÀ_ВЮ' ) ;;	# Good: use default from above.
		( M*N\ *J*_* ) ! : ;;	# Bad: doesn't convert all (or any) UTF-8.
		( * )	# If 'tr' doesn't even work for ASCII, the system is b0rken.
			_Msh_initExit "toupper/tolower init: 'tr' failed" \
					"${CCt}(bad result: '${_Msh_test}')" ;;
		esac ||
		# Try awk instead.
		case $(putln 'mĳn δéjà_вю' | PATH=$DEFPATH exec awk '{print toupper($0)}') in
		( 'MĲN ΔÉJÀ_ВЮ' )
			# ... for handling a variable name (within 'eval'):
			_Msh_tr1="${_Msh_a1}PATH=\\\$DEFPATH command awk "
			_Msh_tr2=": 'awk'${_Msh_a2}"
			_Msh_toupper_tr="${_Msh_tr1}'{print toupper(\\\$0)}') || die \\\"toupper${_Msh_tr2}"
			_Msh_tolower_tr="${_Msh_tr1}'{print tolower(\\\$0)}') || die \\\"tolower${_Msh_tr2}"
			# ... for converting standard input (without 'eval'):
			_Msh_toupper_TR="PATH=\$DEFPATH command awk '{print toupper(\$0)}' || die \"toupper: 'awk' failed\""
			_Msh_tolower_TR="PATH=\$DEFPATH command awk '{print tolower(\$0)}' || die \"tolower: 'awk' failed\"" ;;
		( * )	! : ;;
		esac ||
		# Try gawk (GNU awk) instead, if present.
		{ command -v gawk >/dev/null 2>&1 &&
		case $(putln 'mĳn δéjà_вю' | exec gawk '{print toupper($0)}') in
		( 'MĲN ΔÉJÀ_ВЮ' )
			# We can't rely on 'gawk' being in the default system PATH, so can't use $DEFPATH to
			# harden against subsequent changes in $PATH. So, for robustness, hard-code the path now.
			_Msh_awk=$(command -v gawk)
			case ${_Msh_awk} in
			( /*/gawk ) ;;
			( * )	_Msh_initExit "toupper/tolower init: internal error: can't find 'gawk'!" \
				"${CCt}(bad path: '${_Msh_awk}')" ;;
			esac
			# ... for handling a variable name (within 'eval'):
			_Msh_tr1="${_Msh_a1}${_Msh_awk} "
			_Msh_tr2=": 'gawk'${_Msh_a2}"
			_Msh_toupper_tr="${_Msh_tr1}'{print toupper(\\\$0)}') || die \\\"toupper${_Msh_tr2}"
			_Msh_tolower_tr="${_Msh_tr1}'{print tolower(\\\$0)}') || die \\\"tolower${_Msh_tr2}"
			# ... for converting standard input (without 'eval'):
			_Msh_toupper_TR="${_Msh_awk} '{print toupper(\$0)}' || die \"toupper${_Msh_tr2}: 'gawk' failed\""
			_Msh_tolower_TR="${_Msh_awk} '{print tolower(\$0)}' || die \"tolower${_Msh_tr2}: 'gawk' failed\""
			unset -v _Msh_awk ;;
		( * )	! : ;;
		esac; } ||
		# Try GNU sed instead, if present (check for the \U and \L GNU extensions).
		{ if command -v gnused; then _Msh_sed=gnused
		elif command -v gsed; then _Msh_sed=gsed
		else _Msh_sed=sed
		fi >/dev/null 2>&1
		case $(putln 'mĳn δéjà_вю' | exec "${_Msh_sed}" 's/\(.*\)/\U\1/' 2>/dev/null) in
		( 'MĲN ΔÉJÀ_ВЮ' )
			# We can't rely on GNU 'sed' being in the default system PATH, so can't use $DEFPATH to
			# harden against subsequent changes in $PATH. So, for robustness, hard-code the path now.
			_Msh_sed=$(command -v "${_Msh_sed}")
			case ${_Msh_sed} in
			( /*/sed | /*/gsed | /*/gnused ) ;;
			( * )	_Msh_initExit "toupper/tolower init: internal error: can't find GNU 'sed'!" \
				"${CCt}(bad path: '${_Msh_sed}')" ;;
			esac
			# ... for handling a variable name (within 'eval'):
			_Msh_tr1="${_Msh_a1}${_Msh_sed} "
			_Msh_tr2=": GNU 'sed'${_Msh_a2}"
			_Msh_toupper_tr="${_Msh_tr1}'s/\\(.*\\)/\\U\\1/') || die \\\"toupper${_Msh_tr2}"
			_Msh_tolower_tr="${_Msh_tr1}'s/\\(.*\\)/\\L\\1/') || die \\\"tolower${_Msh_tr2}"
			# ... for converting standard input (without 'eval'):
			_Msh_toupper_TR="${_Msh_sed} 's/\\(.*\\)/\\U\\1/' || die \"toupper: GNU 'sed' failed\""
			_Msh_tolower_TR="${_Msh_sed} 's/\\(.*\\)/\\L\\1/' || die \"tolower: GNU 'sed' failed\""
			unset -v _Msh_sed ;;
		( * )	! : ;;
		esac; } ||
		# Still no improvement? Give up and put up with BUG_CNONASCII.  Perl and Python don't support UTF-8
		# either (!). We could try to enlist the help of AT&T ksh93 or zsh, as they have good UTF-8 support
		# built in, but that seems like overkill; you might as well run modernish on those shells directly.
		{
			# Use LC_ALL=C and don't use character classes to avoid garbling UTF-8 chars on broken systems.
			# ... for handling a variable name (within 'eval'):
			_Msh_tr1="${_Msh_a1}LC_ALL=C PATH=\\\$DEFPATH command tr "
			_Msh_tr2=": 'tr'${_Msh_a2}"
			_Msh_toupper_tr="${_Msh_tr1}a-z A-Z) || die \\\"toupper${_Msh_tr2}"
			_Msh_tolower_tr="${_Msh_tr1}A-Z a-z) || die \\\"tolower${_Msh_tr2}"
			# ... for converting standard input (without 'eval'):
			_Msh_toupper_TR="LC_ALL=C PATH=\$DEFPATH command tr a-z A-Z || die \"toupper: 'tr' failed\""
			_Msh_tolower_TR="LC_ALL=C PATH=\$DEFPATH command tr A-Z a-z || die \"tolower: 'tr' failed\""
			# return unsuccessfully to indicate we're in UTF-8 locale but can only convert ASCII
			unset -v _Msh_a1 _Msh_a2 _Msh_tr1 _Msh_tr2
			_Msh_have BUG_CNONASCII
			return 1
		} ;;
	esac
	unset -v _Msh_a1 _Msh_a2 _Msh_tr1 _Msh_tr2
}

if thisshellhas typeset &&
	typeset -u _Msh_test 2>/dev/null && _Msh_test=gr@lDru1S && identic "${_Msh_test}" GR@LDRU1S && unset -v _Msh_test &&
	typeset -l _Msh_test 2>/dev/null && _Msh_test=gr@lDru1S && identic "${_Msh_test}" gr@ldru1s && unset -v _Msh_test
then	# We can use 'typeset -u' and 'typeset -l' for variables. This is best: we don't need any external commands.
	_Msh_toupper_ts='typeset -u mystring; mystring=\$${1}; ${1}=\$mystring'
	_Msh_tolower_ts='typeset -l mystring; mystring=\$${1}; ${1}=\$mystring'
	_Msh_toupper_TS='typeset -u myline; while IFS= read -r myline; do putln "$myline"; done; put "$myline"'
	_Msh_tolower_TS='typeset -l myline; while IFS= read -r myline; do putln "$myline"; done; put "$myline"'
	# However, sometimes these only support ASCII characters, so do an additional check for non-ASCII --
	# actually just UTF-8 because that's the de facto standard these days. If 'typeset' is lacking for
	# UTF-8, do the same test for an external command and add it as a fallback if it does better.
	case ${LC_ALL:-${LC_CTYPE:-${LANG:-}}} in
	( *[Uu][Tt][Ff]8* | *[Uu][Tt][Ff]-8* )
		typeset -u _Msh_test
		_Msh_test='mĳn δéjà_вю'
		case ${_Msh_test} in
		( 'MĲN ΔÉJÀ_ВЮ' )
			# It worked correctly; use typeset instead of 'awk'
			_Msh_toupper_tr=${_Msh_toupper_ts}
			_Msh_tolower_tr=${_Msh_tolower_ts}
			_Msh_toupper_TR=${_Msh_toupper_TS}
			_Msh_tolower_TR=${_Msh_tolower_TS} ;;
		( M*N\ *J*_* )
			# It didn't transform all the UTF-8. Check if an external command does better.
			if _Msh_tmp_getWorkingTr; then
				_Msh_case_nonascii='case \$${1} in ( *[!\"\$ASCIICHARS\"]* )'
				_Msh_toupper_tr="${_Msh_case_nonascii} ${_Msh_toupper_tr} ;; ( * ) ${_Msh_toupper_ts} ;; esac"
				_Msh_tolower_tr="${_Msh_case_nonascii} ${_Msh_tolower_tr} ;; ( * ) ${_Msh_tolower_ts} ;; esac"
				unset -v _Msh_case_nonascii
			else	# still not better; just use 'typeset' and put up with BUG_CNONASCII
				_Msh_toupper_tr=${_Msh_toupper_ts}
				_Msh_tolower_tr=${_Msh_tolower_ts}
				_Msh_toupper_TR=${_Msh_toupper_TS}
				_Msh_tolower_TR=${_Msh_tolower_TS}
			fi ;;
		( * ) _Msh_initExit "toupper/tolower init: 'typeset -u' failed!" \
				"${CCt}(bad result: '${_Msh_test}')" ;;
		esac
		unset -v _Msh_test ;;
	( * )	# No UTF-8: assume ASCII
		_Msh_toupper_tr=${_Msh_toupper_ts}
		_Msh_tolower_tr=${_Msh_tolower_ts}
		_Msh_toupper_TR=${_Msh_toupper_TS}
		_Msh_tolower_TR=${_Msh_tolower_TS} ;;
	esac
	unset -v _Msh_toupper_ts _Msh_tolower_ts _Msh_toupper_TS _Msh_tolower_TS
# If we don't have 'typeset -u/-l', use an external command. Try hard to avoid an expensive no-op invocation.
elif thisshellhas BUG_NOCHCLASS; then
	# BUG_NOCHCLASS means no (or broken) character classes. All we can portably do to minimise unnecessary external
	# command invocations is check for upper/lowercase *only* if the string is pure ASCII. (Using '*[a-z]*' or
	# '*[A-Z]*' is not good enough as this may let non-ASCII characters slip, depending on the locale. So use the
	# modernish system constants $ASCIILOWER and $ASCIIUPPER which enumerate the entire ASCII alphabet.)
	if _Msh_tmp_getWorkingTr; then
		_Msh_toupper_tr='case \$${1} in ( *[!\"\$ASCIICHARS\"]* | *[\"\$ASCIILOWER\"]* ) '"${_Msh_toupper_tr} ;; esac"
		_Msh_tolower_tr='case \$${1} in ( *[!\"\$ASCIICHARS\"]* | *[\"\$ASCIIUPPER\"]* ) '"${_Msh_tolower_tr} ;; esac"
	else	# BUG_CNONASCII. No external command converts non-ASCII, so it's pointless to check for non-ASCII chars.
		_Msh_toupper_tr='case \$${1} in ( *[\"\$ASCIILOWER\"]* ) '"${_Msh_toupper_tr} ;; esac"
		_Msh_tolower_tr='case \$${1} in ( *[\"\$ASCIIUPPER\"]* ) '"${_Msh_tolower_tr} ;; esac"
	fi
elif thisshellhas BUG_MULTIBYTE; then
	# We've got good character classes, but BUG_MULTIBYTE means they don't support UTF-8 lower/uppercase.
	# A similar workaround is needed: check for pure ASCII before using character classes.
	# (The [:ascii:] class is not POSIX, so we still can't use it.)
	if _Msh_tmp_getWorkingTr; then
		_Msh_toupper_tr='case \$${1} in ( *[!\"\$ASCIICHARS\"]* | *[[:lower:]]* ) '"${_Msh_toupper_tr} ;; esac"
		_Msh_tolower_tr='case \$${1} in ( *[!\"\$ASCIICHARS\"]* | *[[:upper:]]* ) '"${_Msh_tolower_tr} ;; esac"
	else	# BUG_CNONASCII. No external command converts non-ASCII, so it's pointless to check for non-ASCII chars.
		_Msh_toupper_tr='case \$${1} in ( *[[:lower:]]* ) '"${_Msh_toupper_tr} ;; esac"
		_Msh_tolower_tr='case \$${1} in ( *[[:upper:]]* ) '"${_Msh_tolower_tr} ;; esac"
	fi
else
	# This shell has neither problem, so we can reliably avoid invoking 'awk' unnecessarily.
	_Msh_tmp_getWorkingTr
	_Msh_toupper_tr='case \$${1} in ( *[[:lower:]]* ) '"${_Msh_toupper_tr} ;; esac"
	_Msh_tolower_tr='case \$${1} in ( *[[:upper:]]* ) '"${_Msh_tolower_tr} ;; esac"
fi

# With all the code for this shell/OS combination gathered, now define the functions.
eval "${_Msh_toupper_fn}"' {
	case ${#},${1-} in
	( 1, | 1,[0123456789]* | 1,*[!"$ASCIIALNUM"_]* )
		die "toupper: invalid variable name: $1" || return ;;
	( 1,* )	eval "'"${_Msh_toupper_tr}"'" ;;
	( 0, )	'"${_Msh_toupper_TR}"' ;;
	( * )	while let "$#"; do
			case $1 in
			( "" | [0123456789]* | *[!"$ASCIIALNUM"_]* )
				die "toupper: invalid variable name: $1" || return ;;
			esac
			eval "'"${_Msh_toupper_tr}"'"
			shift
		done
	esac
}
'"${_Msh_tolower_fn}"' {
	case ${#},${1-} in
	( 1, | 1,[0123456789]* | 1,*[!"$ASCIIALNUM"_]* )
		die "tolower: invalid variable name: $1" || return ;;
	( 1,* )	eval "'"${_Msh_tolower_tr}"'" ;;
	( 0, )	'"${_Msh_tolower_TR}"' ;;
	( * )	while let "$#"; do
			case $1 in
			( "" | [0123456789]* | *[!"$ASCIIALNUM"_]* )
				die "tolower: invalid variable name: $1" || return ;;
			esac
			eval "'"${_Msh_tolower_tr}"'"
			shift
		done
	esac
}'"$CCn"

unset -v _Msh_toupper_fn _Msh_tolower_fn _Msh_toupper_tr _Msh_tolower_tr _Msh_toupper_TR _Msh_tolower_TR
unset -f _Msh_tmp_getWorkingTr

# -------------------

# Basic system utilities.

# mkcd: make one or more directories, then cd into the last-mentioned one.
# All given arguments are passed to mkdir, so usage depends on mkdir.
mkcd() {
	PATH=$DEFPATH command mkdir "$@" || die "mkcd: mkdir failed"
	shift "$(( $# - 1 ))"
	command cd -- "$1" || die "mkcd: cd failed"
}

# -------------------

# Initialization, phase 2.

# At this point, all main modernish library functionality was initialised
# successfully, so everything can be used except features based on aliases
# (such as 'not', 'so').

# If shell supports it, then set modernish functions to read-only.
if thisshellhas ROFUNC; then
	readonly -f \
	@ROFUNC@	# install.sh will replace this tag
fi 2>/dev/null

# On zsh with broken POSIX 'readonly', we redefined 'readonly' as an alias for
# 'typeset -rg' near the top. For purposes other than modernish initalisation,
# we can properly fix the bug by making it conditional upon posixbuiltins,
# albeit at the cost of forking a subshell for every 'readonly' invocation.
if isset ZSH_VERSION && alias readonly >/dev/null 2>&1 && thisshellhas --rw=[[; then
	alias readonly='typeset -r"$([[ -o posixbuiltins ]] && builtin echo g)"'
fi

# Work around intermittent ksh93 bug (at least on version 93u+ 2012-08-01)
# where multibyte locale settings corrupt the shell-quoting in the output of
# commands like 'export -p' and 'trap'. Triggering a locale re-init fixes it.
if thisshellhas KSH93FUNC; then
	LC_ALL=foo_BAR.baz command true 2>/dev/null  # BUG_CMDSPASGN compat: 'true' is a regular builtin
fi

# Internal function to pre-load the modules 'used' by hashbang comments for
# ksh93 compatibility. This is needed for aliases set in modules to be
# properly expanded on ksh93.
# Only the 'use' command is allowed here (more specific commands may be
# allowed in the future). No shell grammar is parsed: all arguments are
# whitespace-separated with no way of quoting them to include whitespace;
# variables and compound commands won't work; etc. An argument starting with
# '#' causes it and the rest of the line to be ignored. It is considered a
# fatal error for any command to yield an exit status > 0.
_Msh_tmp_doHashbangPreload() {
	# eval all immediately adjacent hashbang lines that contain non-pathname commands
	while IFS='' read -r _Msh_doHbPl_L 2>/dev/null; do
		startswith "${_Msh_doHbPl_L}" "#!" || break
		# remove '#!'
		_Msh_doHbPl_L=${_Msh_doHbPl_L#??}
		# isolate command name
		_Msh_doHbPl_a=${_Msh_doHbPl_L#*"${_Msh_doHbPl_L%%[!"$WHITESPACE"]*}"}	# trim left whitespace		"
		_Msh_doHbPl_a=${_Msh_doHbPl_a%%["$WHITESPACE"]*}			# trim right arguments + whitespace
		contains "${_Msh_doHbPl_a}" '/' && continue
		_Msh_doHbPl_C=''
		push IFS -f
		unset -v IFS; set -f  # default field splitting; no globbing
		for _Msh_doHbPl_a in ${_Msh_doHbPl_L}; do
			case ${_Msh_doHbPl_C} in
			( '' )	case ${_Msh_doHbPl_a} in
				# whitelist allowed commands below
				( use ) _Msh_doHbPl_C=${_Msh_doHbPl_a} ;;
				( * )	die "invalid hashbang command: ${_Msh_doHbPl_L}" ;;
				esac ;;
			( * )	# don't allow any shell grammar: shellquote each whitespace-separated argument
				case ${_Msh_doHbPl_a} in
				( \#* )	break ;; # comment
				esac
				shellquote _Msh_doHbPl_a
				_Msh_doHbPl_C=${_Msh_doHbPl_C}\ ${_Msh_doHbPl_a} ;;
			esac
		done
		pop IFS -f
		eval "${_Msh_doHbPl_C}" || die "hashbang command failed: ${_Msh_doHbPl_L}"
	done
	unset -v _Msh_doHbPl_C _Msh_doHbPl_a	# keep last line in _Msh_doHbPl_L
}

# Cleanup.
case ${_Msh_IFS+s} in
( s )	IFS=${_Msh_IFS}; unset -v _Msh_IFS ;;
( * )	unset -v IFS ;;
esac
PATH=${_Msh_PATH}
unset -v _Msh_PATH _Msh_test _Msh_test2 _Msh_ftlcount
unset -f _Msh_testFn _Msh_testFn2 _Msh_initExit _Msh_have

# With init succeeded, time to make these permanent.
#readonly MSH_VERSION MSH_SHELL MSH_PREFIX	# installer will uncomment this

# --------------------
# ------- MAIN -------
# --------------------

# Find out how modernish was invoked and launch the invoking program if necessary.
ME=$0	# temporary identity for possible error messages
if ! endswith "$0" '/modernish' && ! identic "$0" 'modernish'; then

	# --- modernish was sourced (simple use) ---
	if isset -i; then
		# interactive shell: be welcoming
		readonly "ME=modernish on ${0#-}"
		putln "Welcome to the modernish age (version $MSH_VERSION)."
		thisshellhas --cache  # use --cache before --show so results aren't cached in a subshell below
		# do a nice sorted and indented output of shell capabilities
		put 'This shell has: '				# length 16
		(PATH=$DEFPATH
			thisshellhas --show |
			sort |
			paste -s -d ' ' - |
			fold -s -w "$(( ${COLUMNS:-80} - 16 ))" |
			sed '2,$ s/^/                /')	# 16 spaces
		eval trap >/dev/null	# prevent overwriting pre-existing traps
		pushtrap 'putln "Exiting modernish $MSH_VERSION. Bye."' EXIT
	else
		# non-interactive shell
		readonly "ME=$0"
		if is -L reg "$ME" && can read "$ME"; then
			_Msh_tmp_doHashbangPreload < "$ME"
			unset -v _Msh_doHbPl_L
		fi
	fi
	unset -f _Msh_tmp_doHashbangPreload
	# Restore 'allexport' option if it was set
	if isset _Msh_allexport; then
		set -a
		unset -v _Msh_allexport
	fi
	# Resume parent program or return to command prompt.
	# We used to 'return' from the dot script here, but yash < 2.44 in interactive mode doesn't like it.
	# Instead, enclose the rest in an extra else ... fi.

else

# --- modernish *is* the shell (cross-platform use, must be portable) ---
# (e.g. '#!/usr/bin/env modernish' or 'modernish -c "commands here"'):

# Provide one consistent modernish version of the notoriously unportable 'echo', so cross-shell
# modernish programs can safely expect the same behaviour. This version does not interpret any control
# characters and supports only one option, '-n', which, like BSD 'echo', suppresses the newline.
# However, unlike BSD 'echo', if '-n' is the only argument, it is not interpreted as an option and the
# string '-n' is printed instead. This makes it safe to output arbitrary data using this version of
# 'echo' as long as it is given as a single argument (using quoting if needed).
# **NOTE**: This is provided for adapting existing scripts. The use of 'put' and 'putln' is preferred
# for new scripts.
echo() {
	case ${#},${1-} in
	( 0, )   putln ;;
	( 1,* )  putln "$1" ;;
	( *,-n ) shift; put "$@" ;;
	( * )	 put "$@$CCn" ;;
	esac
}
if thisshellhas ROFUNC; then
	readonly -f echo
fi

if let "$#"; then
	# parse standard shell options.
	unset -v _Msh_script _Msh_noexec _Msh_xtrace
	while match "${1:-}" '[+-]*'; do
		case $1 in
		( [+-][!-]?* ) # split a set of combined options
			_Msh_opts=${1#?}
			_Msh_plusmin=${1%"$_Msh_opts"}
			shift
			while ! empty "${_Msh_opts}"; do
				if match "${_Msh_opts}" "[o]*"; then
				# if the option requires an argument, split it and break out of loop
				# (it is always the last in a combined set)
					_Msh_arg=${_Msh_plusmin}${_Msh_opts%"${_Msh_opts#?}"}
					push _Msh_arg
					_Msh_opts=${_Msh_opts#?}
					if ! empty "${_Msh_opts}"; then
						_Msh_arg=${_Msh_opts}
						push _Msh_arg
					fi
					break
				fi
				# split options that do not require arguments (and invalid options) until we run out
				_Msh_arg=${_Msh_plusmin}${_Msh_opts%"${_Msh_opts#?}"}
				push _Msh_arg
				_Msh_opts=${_Msh_opts#?}
			done
			while pop _Msh_arg; do
				set -- "${_Msh_arg}" "$@"
			done
			unset -v _Msh_opts _Msh_arg _Msh_plusmin
			continue ;;
		( -c )	_Msh_script= ;;
		( +c )	unset -v _Msh_script ;;
		( -i | -l )
			_Msh_doExit 2 "To use modernish interactively, source it ('. modernish') in your shell profile."
			;;
		( +i | +l ) ;;
		( [+-]o )
			let "$# >= 2" || _Msh_doExit 2 "option requires argument: -o"
			case $1,$2 in
			( -o,errexit )
				_Msh_doExit 2 "'$1 $2' not supported; use harden() instead." ;;
			( ?o,noexec )
				_Msh_noexec=${1%o}n ;;
			( ?o,xtrace )
				_Msh_xtrace=${1%o}x ;;
			( * )	set "$1" "$2" || exit ;;
			esac
			shift
			;;
		( -e )	_Msh_doExit 2 "'-e' not supported; use harden() instead."
			;;
		( [+-]n )
			_Msh_noexec=$1 ;;
		( [+-]x )
			_Msh_xtrace=$1 ;;
		( [+-][!-]* )
			set "$1" || exit ;;
		( --use | --use= )
			_Msh_doExit 2 "option requires argument: --use" ;;
		( --use=* )
			# Preload module. Safely field-split the argument to allow for arguments to modules.
			_Msh_tmp_doUse() {
				push IFS -f
				unset -v IFS; set -f
				set -- $1
				pop IFS -f
				use "$@"
			}
			_Msh_tmp_doUse "${1#--use=}"
			unset -f _Msh_tmp_doUse ;;
		( --version )
			putln "$MSH_VERSION"
			exit
			;;
		( --test )
			shift
			_Msh_tmp_doHashbangPreload < "$MSH_PREFIX/libexec/modernish/tests/run.sh" || exit
			unset -f _Msh_tmp_doHashbangPreload
			unset -v _Msh_doHbPl_L
			. "$MSH_PREFIX/libexec/modernish/tests/run.sh"
			exit
			;;
		( -- )
			shift
			break
			;;
		( * )
			_Msh_doExit 2 "invalid option: $1"
			;;
		esac
		shift
	done
fi
if isset _Msh_xtrace && { identic "$PS4" "+ " || identic "$PS4" "+%N:%i> "; }; then
	# If PS4 is default, set a useful PS4 for xtrace output.
	# The ${foo#{foo%/*/*}/} substitutions below are to trace just the last two
	# elements of path names, instead of the full paths which can be very long.
	if isset BASH_VERSION; then
		PS4='+ [${BASH_SOURCE+${BASH_SOURCE#${BASH_SOURCE%/*/*}/},}${FUNCNAME+$FUNCNAME,}${LINENO+$LINENO,}$?] '
	elif isset ZSH_VERSION; then
		PS4='+ [${funcfiletrace+${funcfiletrace#${funcfiletrace%/*/*}/},}${funcstack+${funcstack#${funcstack%/*/*}/},}${LINENO+$LINENO,}$?] '
	elif thisshellhas KSH93FUNC && (eval '[[ -n ${.sh.file+s} ]]') 2>/dev/null; then  # ksh93
		PS4='+ [${.sh.file+${.sh.file#${.sh.file%/*/*}/},}${.sh.fun+${.sh.fun},}${LINENO+$LINENO,}$?] '
	else	# plain POSIX
		PS4='+ [${LINENO+$LINENO,}$?] '
	fi
fi
if isset _Msh_script; then
	# A script was given with the -c option.
	# Other shells take the first non-option argument as the script and pass the rest on to the PPs for
	# the script, starting with $0; act alike, except we can't set $0 so we'll set $ME instead.
	let "$#" && _Msh_script=$1 && shift || _Msh_doExit 2 'the -c option was specified but no script was given'
	let "$#" && ME=$1 && shift
	readonly ME
	thisshellhas BUG_HDOCMASK && _Msh_umask=$(umask) && umask u+r
	_Msh_tmp_doHashbangPreload <<-EOF
	${_Msh_script}
	EOF
	thisshellhas BUG_HDOCMASK && umask "${_Msh_umask}" && unset -v _Msh_umask
	unset -f _Msh_tmp_doHashbangPreload
	isset _Msh_allexport && set -a && unset -v _Msh_allexport
	eval "unset -v _Msh_script _Msh_doHbPl_L _Msh_noexec _Msh_xtrace" \
		"${_Msh_noexec+${CCn}set ${_Msh_noexec}}" \
		"${_Msh_xtrace+${CCn}set ${_Msh_xtrace}}" \
		"${CCn}${_Msh_script}"
elif let "$#"; then
	# A script file was given as the first argument.
	is -L reg "$1" || _Msh_doExit 127 "file not found: $1"
	readonly "ME=$1"
	shift
	_Msh_tmp_doHashbangPreload < "$ME"
	unset -f _Msh_tmp_doHashbangPreload
	unset -v _Msh_doHbPl_L
	isset _Msh_allexport && set -a && unset -v _Msh_allexport
	case $ME in	# keep '.' from searching in PATH if no directory was given
	( */* )	isset _Msh_xtrace && eval "unset -v _Msh_xtrace; set ${_Msh_xtrace}"
		. "$ME" ;;
	( * )	isset _Msh_xtrace && eval "unset -v _Msh_xtrace; set ${_Msh_xtrace}"
		. "./$ME" ;;
	esac
elif is onterminal 0; then
	# This is where we wish it were possible to switch a non-interactive shell to interactive and go to
	# its command prompt, retaining all the shell functions we just set, but no shell supports this.
	# We could fake a simple interactive shell here using a loop with 'read', but who would use that?
	_Msh_doExit 2 "To use modernish interactively, source it ('. modernish') in your shell profile."
else
	# We're reading a modernish script from standard input; the user did
	# something like 'echo "$scriptcode" | modernish' or 'modernish <<"EOF"'
	readonly ME
	_Msh_tmp_doHashbangPreload
	unset -f _Msh_tmp_doHashbangPreload
	isset _Msh_allexport && set -a && unset -v _Msh_allexport
	eval "unset -v _Msh_doHbPl_L _Msh_noexec _Msh_xtrace" \
		"${_Msh_noexec+${CCn}set ${_Msh_noexec}}" \
		"${_Msh_xtrace+${CCn}set ${_Msh_xtrace}}" \
		"${CCn}${_Msh_doHbPl_L}${CCn}$(PATH=$DEFPATH exec cat)"
fi

fi # if ! endswith "$0" '/modernish' && ! identic "$0" 'modernish'
